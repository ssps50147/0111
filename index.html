<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>é˜¿é¹¿é¹¿æ–‡å‰µ-è²ªé£Ÿé¹¿(åƒé¹¿ç²‰)</title>

  <style>
    :root{
      --bg1:#ffd6e7;
      --bg2:#fff4f9;
      --card:#ffffffcc;
      --text:#111;
      --shadow: rgba(0,0,0,.12);
      --safeT: env(safe-area-inset-top);
      --safeB: env(safe-area-inset-bottom);
    }
    html,body{height:100%; margin:0;}
    body{
      font-family: system-ui,-apple-system,"Segoe UI","Noto Sans TC","PingFang TC","Microsoft JhengHei",sans-serif;
      background: linear-gradient(180deg,var(--bg1),var(--bg2));
      color: var(--text);
      display:flex;
      justify-content:center;
    }
    .wrap{
      width:min(580px, 100%);
      padding: calc(12px + var(--safeT)) 12px calc(12px + var(--safeB));
      box-sizing:border-box;
    }
    .topbar{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border-radius:16px;
      background: var(--card);
      box-shadow: 0 8px 20px var(--shadow);
      backdrop-filter: blur(8px);
    }
    .title{display:flex; flex-direction:column; gap:4px;}
    .title b{font-size:15px; line-height:1.1;}
    .title small{opacity:.75; line-height:1.1;}
    .pill{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; align-items:center;}
    .btn{
      border:0;
      padding:10px 12px;
      border-radius:14px;
      background:#111;
      color:#fff;
      font-weight:900;
      cursor:pointer;
      box-shadow: 0 8px 16px rgba(0,0,0,.12);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      white-space:nowrap;
    }
    .btn.secondary{
      background:#fff;
      color:#111;
      border:1px solid rgba(0,0,0,.12);
      box-shadow:none;
    }
    .tag{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px;
      border-radius:999px;
      background:#fff;
      border:1px solid rgba(0,0,0,.12);
      font-size:12px;
      font-weight:900;
      white-space:nowrap;
    }

    .row{display:flex; gap:12px; margin-top:12px; align-items:stretch; flex-wrap:wrap;}
    .panel{
      flex:1 1 260px;
      padding:12px;
      border-radius:16px;
      background: var(--card);
      box-shadow: 0 8px 20px var(--shadow);
      backdrop-filter: blur(8px);
    }
    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px 10px;
      align-items:center;
      font-size:13px;
    }
    .kv .v{font-weight:900;}
    .hint{font-size:12px; opacity:.75; margin-top:8px; line-height:1.45;}

    .gamebox{
      margin-top:12px;
      padding:12px;
      border-radius:20px;
      background: rgba(255,255,255,.68);
      box-shadow: 0 10px 26px rgba(0,0,0,.12);
    }
    canvas{
      width:100%;
      height:auto;
      border-radius:16px;
      background:#0b0b0f;
      touch-action:none;
      display:block;
    }
    .controls{
      margin-top:10px;
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
    }
    .pad{
      padding:12px 10px;
      border-radius:16px;
      border:1px solid rgba(0,0,0,.12);
      background:#fff;
      font-weight:900;
      text-align:center;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .pad:active{transform: translateY(1px);}

    .footer{
      margin-top:12px;
      font-size:12px;
      opacity:.7;
      text-align:center;
      line-height:1.45;
    }

    .toggleRow{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      margin-bottom:10px;
      flex-wrap:wrap;
    }
    .toggle{
      display:flex; align-items:center; gap:8px;
      font-size:12px; font-weight:900;
      white-space:nowrap;
    }
    .toggle input{transform: scale(1.15);}
    .slider{
      display:flex; align-items:center; gap:8px;
      font-size:12px; font-weight:900;
      white-space:nowrap;
    }
    .slider input[type="range"]{ width:120px; }

    .namebox{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:flex-end;
      flex-wrap:wrap;
    }
    .namebox input{
      flex: 1 1 140px;
      border:1px solid rgba(0,0,0,.15);
      border-radius:12px;
      padding:10px 12px;
      font-weight:900;
      outline:none;
      background:#fff;
    }

    /* Modal */
    .mask{
      position:fixed; inset:0;
      background: rgba(0,0,0,.48);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index:50;
    }
    .modal{
      width:min(580px, 100%);
      border-radius:18px;
      background:#fff;
      padding:14px;
      box-shadow: 0 20px 60px rgba(0,0,0,.35);
    }
    .modalHead{
      display:flex; gap:12px; align-items:center; justify-content:space-between;
    }
    .modalHeadLeft{
      display:flex; gap:12px; align-items:center;
      min-width:0;
    }
    .avatar{
      width:54px; height:54px;
      border-radius:14px;
      border:1px solid rgba(0,0,0,.12);
      background:#fff;
      object-fit:cover;
      flex: 0 0 auto;
    }
    .modal h3{margin:6px 0 8px; font-size:16px;}
    .modal p{margin:0 0 10px; font-size:13px; opacity:.88; line-height:1.55;}
    .modal .actions{
      display:flex; gap:10px; justify-content:flex-end; margin-top:12px; flex-wrap:wrap;
    }
    .rank{
      margin-top:10px;
      border-top:1px dashed rgba(0,0,0,.15);
      padding-top:10px;
      font-size:13px;
    }
    .rank ol{margin:8px 0 0 0; padding:0; list-style:none;}
    .rank li{
      margin:8px 0;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:8px 10px;
      border-radius:14px;
      background: rgba(0,0,0,.04);
    }
    .rankLeft{
      display:flex; align-items:center; gap:10px;
      min-width:0;
    }
    .rankAva{
      width:36px; height:36px;
      border-radius:12px;
      border:1px solid rgba(0,0,0,.12);
      object-fit:cover;
      background:#fff;
      flex: 0 0 auto;
    }
    .rankName{
      font-weight:900;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width: 280px;
    }
    .rankScore{font-weight:900;}
  </style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="title">
      <b>é˜¿é¹¿é¹¿æ–‡å‰µ-è²ªé£Ÿé¹¿(åƒé¹¿ç²‰)</b>
      <small>
        ç©å®¶ï¼š<span id="playerName">Guest</span>ã€€ï½œã€€å€ç‡ï¼š<span id="mult">x1</span>
        <span id="x2Tag" class="tag" style="display:none; margin-left:8px;">x2 åŠ æˆä¸­</span>
      </small>
    </div>
    <div class="pill">
      <span class="tag">åˆ†æ•¸ <span id="score">0</span></span>
      <span class="tag">æœ€é«˜ <span id="best">0</span></span>
      <button class="btn secondary" id="btnRank">æŸ¥è©¢æ’è¡Œæ¦œ</button>
      <button class="btn secondary" id="btnHow">ç©æ³•</button>
      <button class="btn" id="btnStart">é–‹å§‹</button>
    </div>
  </div>

  <div class="row">
    <div class="panel">
      <div class="kv">
        <div>é€Ÿåº¦</div><div class="v" id="spd">æ­£å¸¸</div>
        <div>é€£åƒ</div><div class="v" id="streak">0</div>
        <div>å ´ä¸Šç‰©ä»¶</div><div class="v" id="liveItems">0/1</div>
        <div>èº«é«”é•·åº¦</div><div class="v" id="len">1</div>
      </div>
      <div class="hint">
        åŠ åˆ†é …ç›®æ‰ç®—é€£åƒï¼›åƒåˆ°åœ°é›·æœƒä¸­æ–·é€£åƒä¸¦é‡ç½®é€Ÿåº¦ã€‚<br/>
        è¶…é 3 ç§’æ²’åƒåˆ°åŠ åˆ†é …ç›®ï¼Œé€£åƒæœƒé–‹å§‹ç·©æ…¢ä¸‹é™ï¼ˆæ¯ tick ç´„ -0.35ï¼‰ã€‚
      </div>
    </div>

    <div class="panel">
      <div class="toggleRow">
        <div class="toggle"><label><input type="checkbox" id="bgmOn" checked> BGM</label></div>
        <div class="slider">éŸ³é‡ <input id="bgmVol" type="range" min="0" max="100" value="35"></div>
      </div>
      <div class="toggleRow" style="margin-bottom:0;">
        <div class="toggle"><label><input type="checkbox" id="sfxOn" checked> éŸ³æ•ˆ</label></div>
        <div class="slider">éŸ³é‡ <input id="sfxVol" type="range" min="0" max="100" value="55"></div>
      </div>

      <div class="namebox" style="margin-top:10px;">
        <input id="nameInput" maxlength="12" placeholder="è¼¸å…¥æš±ç¨±ï¼ˆå¯é¸ï¼‰" />
        <button class="btn secondary" id="btnSetName">å¥—ç”¨</button>
      </div>

      <div class="hint">
        æ’è¡Œæ¦œä½¿ç”¨ LocalStorageï¼ˆå…å¾Œç«¯ï¼‰ã€‚<br/>
        LINE/iOS éœ€ç¬¬ä¸€æ¬¡é»æ“Šå¾Œæ‰å…è¨±æ’­æ”¾è²éŸ³ï¼ˆå·²è™•ç†ï¼‰ã€‚
      </div>
    </div>
  </div>

  <div class="gamebox">
    <canvas id="cv" width="486" height="486"></canvas>

    <div class="controls">
      <div class="pad" id="left">â¬…ï¸</div>
      <div class="pad" id="up">â¬†ï¸</div>
      <div class="pad" id="right">â¡ï¸</div>
      <div class="pad" id="down" style="grid-column: 2 / 3;">â¬‡ï¸</div>
    </div>
  </div>

  <div class="footer">
    ç‰©ä»¶ã€ŒéæœŸã€ä¸æ¶ˆå¤±ï¼Œæœƒæ”¹æˆã€Œæ›ä½ç½®/æ›è§’è‰²ã€ç¶­æŒæ´»å‹•æ„Ÿã€‚<br/>
    çµæŸåŠ æˆï¼šæ¯å¤šä¸€æ ¼èº«é«” +1 åˆ†ï¼ˆä»¥åˆå§‹é•·åº¦ 1 ç‚ºåŸºæº–ï¼‰ã€‚
  </div>
</div>

<!-- å…±ç”¨ Modal -->
<div class="mask" id="mask">
  <div class="modal">
    <div class="modalHead">
      <div class="modalHeadLeft">
        <img id="modalAva" class="avatar" alt="é¹¿é¹¿" />
        <div style="min-width:0;">
          <h3 id="modalTitle" style="margin:0 0 6px;">æç¤º</h3>
          <div style="font-size:12px;opacity:.8;line-height:1.35;" id="modalSub"></div>
        </div>
      </div>
      <div>
        <span class="tag">åˆ†æ•¸ <span id="modalScore">0</span></span>
      </div>
    </div>

    <p id="modalText" style="margin-top:10px;"></p>

    <div class="rank" id="rankBox" style="display:none;">
      <b>ğŸ† æ’è¡Œæ¦œï¼ˆå‰ 10 åï¼‰</b>
      <ol id="rankList"></ol>
    </div>

    <div class="actions">
      <button class="btn secondary" id="btnClose">é—œé–‰</button>
      <button class="btn secondary" id="btnClearRank" style="display:none;">æ¸…ç©ºæ’è¡Œæ¦œ</button>
      <button class="btn" id="btnGo" style="display:none;">é–‹å§‹éŠæˆ²</button>
      <button class="btn" id="btnAgain" style="display:none;">å†ç©ä¸€æ¬¡</button>
    </div>
  </div>
</div>

<script>
(() => {
  /***********************
   * åœ–ç‰‡ç¶²å€ï¼ˆä½ æä¾›ï¼‰
   ***********************/
  const URLS = {
    HEAD:  "https://github.com/z883662/Aruru/blob/main/lulu1.png?raw=true",
    ASHUI: "https://github.com/z883662/Aruru/blob/main/lulu4.png?raw=true",
    DAD:   "https://github.com/z883662/Aruru/blob/main/lulu2.png?raw=true",
    MOM:   "https://github.com/z883662/Aruru/blob/main/lulu3.png?raw=true",
    ANGRY: "https://github.com/z883662/Aruru/blob/main/lulu5.png?raw=true",
  };
  const LULU_POOL = [URLS.HEAD, URLS.DAD, URLS.MOM, URLS.ASHUI, URLS.ANGRY];
  const pickRandomAva = () => LULU_POOL[Math.floor(Math.random()*LULU_POOL.length)];

  /***********************
   * ä½ æŒ‡å®šï¼šGRID / SCALE
   ***********************/
  const GRID = 18;
  const TARGET_SCALE = 1.25;
  const HEAD_SCALE = 1.25;

  /***********************
   * å„²å­˜ key
   ***********************/
  const STORAGE_KEY = "aruru_snake_board_v4";
  const BEST_KEY = "aruru_snake_best_v4";
  const NAME_KEY = "aruru_snake_name_v4";
  const AUDIO_KEY = "aruru_snake_audio_v4";

  /***********************
   * Canvas
   ***********************/
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  const CELL = cv.width / GRID;

  /***********************
   * UI
   ***********************/
  const $playerName = document.getElementById("playerName");
  const $nameInput = document.getElementById("nameInput");
  const $score = document.getElementById("score");
  const $best = document.getElementById("best");
  const $spd = document.getElementById("spd");
  const $streak = document.getElementById("streak");
  const $mult = document.getElementById("mult");
  const $len = document.getElementById("len");
  const $liveItems = document.getElementById("liveItems");
  const $x2Tag = document.getElementById("x2Tag");

  // Modal
  const mask = document.getElementById("mask");
  const modalAva = document.getElementById("modalAva");
  const modalTitle = document.getElementById("modalTitle");
  const modalSub = document.getElementById("modalSub");
  const modalText = document.getElementById("modalText");
  const modalScore = document.getElementById("modalScore");
  const rankBox = document.getElementById("rankBox");
  const rankList = document.getElementById("rankList");
  const btnClose = document.getElementById("btnClose");
  const btnGo = document.getElementById("btnGo");
  const btnAgain = document.getElementById("btnAgain");
  const btnClearRank = document.getElementById("btnClearRank");

  const fmt = (n) => (Number(n)||0).toFixed(2).replace(/\.?0+$/,"");
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const randRange = (a,b)=>Math.floor(a + Math.random()*(b-a+1));

  function openModal({title, sub="", text="", score=0, showRank=false, showGo=false, showAgain=false, showClear=false, rankData=null, avaUrl=null}) {
    modalTitle.textContent = title;
    modalSub.textContent = sub;
    modalText.innerHTML = text.replace(/\n/g,"<br/>");
    modalScore.textContent = fmt(score);
    modalAva.src = avaUrl || pickRandomAva();

    rankBox.style.display = showRank ? "block" : "none";
    if (showRank) renderRank(rankData || loadBoard());

    btnGo.style.display = showGo ? "inline-flex" : "none";
    btnAgain.style.display = showAgain ? "inline-flex" : "none";
    btnClearRank.style.display = showClear ? "inline-flex" : "none";

    mask.style.display = "flex";
  }
  const closeModal = ()=> mask.style.display = "none";
  btnClose.addEventListener("click", closeModal);

  /***********************
   * åœ–ç‰‡é è¼‰
   ***********************/
  const SPR = {};
  function loadImg(url){
    return new Promise((resolve) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = url;
    });
  }
  async function preload() {
    for (const [k, url] of Object.entries(URLS)) SPR[k] = await loadImg(url);
    for (const url of LULU_POOL) await loadImg(url);
  }

  /***********************
   * ç©å®¶æš±ç¨±ï¼ˆç„¡ LIFFï¼‰
   ***********************/
  let playerName = localStorage.getItem(NAME_KEY) || "Guest";
  $playerName.textContent = playerName;
  $nameInput.value = (playerName === "Guest") ? "" : playerName;

  document.getElementById("btnSetName").addEventListener("click", () => {
    const v = ($nameInput.value || "").trim().slice(0,12);
    playerName = v || "Guest";
    localStorage.setItem(NAME_KEY, playerName);
    $playerName.textContent = playerName;
    sfxBeep(660, 0.06, "triangle", 0.12);
  });

  /***********************
   * è²éŸ³ï¼šBGM/SFX + éŸ³é‡
   ***********************/
  const $bgmOn = document.getElementById("bgmOn");
  const $sfxOn = document.getElementById("sfxOn");
  const $bgmVol = document.getElementById("bgmVol");
  const $sfxVol = document.getElementById("sfxVol");

  let audioCtx = null;
  let master = null;
  let bgmGain = null;
  let sfxGain = null;
  let bgmTimer = null;

  function loadAudioPrefs(){
    try{
      const p = JSON.parse(localStorage.getItem(AUDIO_KEY) || "{}");
      if (typeof p.bgmOn === "boolean") $bgmOn.checked = p.bgmOn;
      if (typeof p.sfxOn === "boolean") $sfxOn.checked = p.sfxOn;
      if (typeof p.bgmVol === "number") $bgmVol.value = String(p.bgmVol);
      if (typeof p.sfxVol === "number") $sfxVol.value = String(p.sfxVol);
    } catch {}
  }
  function saveAudioPrefs(){
    localStorage.setItem(AUDIO_KEY, JSON.stringify({
      bgmOn: $bgmOn.checked,
      sfxOn: $sfxOn.checked,
      bgmVol: Number($bgmVol.value),
      sfxVol: Number($sfxVol.value),
    }));
  }
  loadAudioPrefs();

  function ensureAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    master = audioCtx.createGain();
    master.gain.value = 0.9;
    master.connect(audioCtx.destination);

    bgmGain = audioCtx.createGain();
    sfxGain = audioCtx.createGain();
    bgmGain.connect(master);
    sfxGain.connect(master);
    applyVolumes();
  }

  function applyVolumes(){
    if (!bgmGain || !sfxGain) return;
    const bgm = Number($bgmVol.value) / 100;
    const sfx = Number($sfxVol.value) / 100;
    bgmGain.gain.value = clamp(bgm,0,1) * 0.28;
    sfxGain.gain.value = clamp(sfx,0,1) * 0.9;
  }

  $bgmOn.addEventListener("change", () => { saveAudioPrefs(); if ($bgmOn.checked) startBGM(); else stopBGM(); });
  $sfxOn.addEventListener("change", saveAudioPrefs);
  $bgmVol.addEventListener("input", () => { applyVolumes(); saveAudioPrefs(); });
  $sfxVol.addEventListener("input", () => { applyVolumes(); saveAudioPrefs(); });

  function sfxBeep(freq, dur=0.08, type="sine", vol=0.18) {
    if (!$sfxOn.checked) return;
    ensureAudio();
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g);
    g.connect(sfxGain);
    o.start(t0);
    o.stop(t0 + dur + 0.03);
  }

  function startBGM() {
    if (!$bgmOn.checked) return;
    ensureAudio();
    stopBGM();

    const seq = [
      [392, 494, 587],
      [440, 554, 659],
      [349, 440, 523],
      [392, 494, 587],
    ];
    let step = 0;

    bgmTimer = setInterval(() => {
      if (!$bgmOn.checked || !audioCtx) return;
      const chord = seq[step % seq.length]; step++;

      chord.forEach((f, i) => {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "triangle";
        o.frequency.value = f * (i === 0 ? 0.5 : 1);
        o.connect(g);
        g.connect(bgmGain);

        const t = audioCtx.currentTime + i * 0.02;
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(0.22, t + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);

        o.start(t);
        o.stop(t + 0.22);
      });
    }, 520);
  }
  function stopBGM(){ if (bgmTimer) clearInterval(bgmTimer); bgmTimer = null; }

  function unlockAudio() {
    ensureAudio();
    if (audioCtx.state === "suspended") audioCtx.resume();
    if ($bgmOn.checked) startBGM();
    window.removeEventListener("pointerdown", unlockAudio);
    window.removeEventListener("touchstart", unlockAudio);
    window.removeEventListener("keydown", unlockAudio);
  }
  window.addEventListener("pointerdown", unlockAudio, {once:false});
  window.addEventListener("touchstart", unlockAudio, {once:false});
  window.addEventListener("keydown", unlockAudio, {once:false});

  /***********************
   * æ’è¡Œæ¦œï¼ˆLocalStorageï¼‰+ éš¨æ©Ÿé¹¿é¹¿åœ–
   ***********************/
  function loadBoard(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]"); } catch { return []; } }
  function saveBoard(list){ localStorage.setItem(STORAGE_KEY, JSON.stringify(list)); }
  function addScoreToBoard(entry){
    const list = loadBoard();
    list.push(entry);
    list.sort((a,b) => b.score - a.score);
    const top10 = list.slice(0,10);
    saveBoard(top10);
    return top10;
  }
  function clearBoard(){ localStorage.removeItem(STORAGE_KEY); }

  function renderRank(list){
    const data = Array.isArray(list) ? list : loadBoard();
    rankList.innerHTML = "";
    data.slice(0,10).forEach((r, i) => {
      const li = document.createElement("li");
      const left = document.createElement("div");
      left.className = "rankLeft";

      const ava = document.createElement("img");
      ava.className = "rankAva";
      ava.src = r.avaUrl || pickRandomAva();
      ava.alt = "é¹¿é¹¿";

      const name = document.createElement("div");
      name.className = "rankName";
      name.textContent = `${i+1}. ${r.name || "ç©å®¶"}`;

      left.appendChild(ava);
      left.appendChild(name);

      const sc = document.createElement("div");
      sc.className = "rankScore";
      sc.textContent = fmt(r.score ?? 0);

      li.appendChild(left);
      li.appendChild(sc);
      rankList.appendChild(li);
    });
  }

  btnClearRank.addEventListener("click", () => {
    clearBoard();
    renderRank([]);
    sfxBeep(330, 0.08, "square", 0.18);
  });

  document.getElementById("btnRank").addEventListener("click", () => {
    openModal({
      title: "æ’è¡Œæ¦œ",
      sub: "éš¨æ©Ÿé¹¿é¹¿é ­è²¼ï¼‹å‰ 10 å",
      text: "ï¼ˆæœ¬æ’è¡Œæ¦œå„²å­˜åœ¨ä½ çš„è£ç½® LocalStorageï¼‰",
      score: currentScoreFinalForUI(),
      showRank: true,
      showClear: true,
      avaUrl: pickRandomAva()
    });
  });

  /***********************
   * ç‰©ä»¶å®šç¾©ï¼ˆä½ æŒ‡å®šï¼‰
   ***********************/
  const ITEM_DEFS = [
    { key:"ASHUI", name:"é˜¿æ°´",    prob:0.35, score:+1,   grow:+1,   isPositive:true },
    { key:"DAD",   name:"é¹¿çˆ¸",    prob:0.25, score:+1.5, grow:+1.5, isPositive:true },
    { key:"MOM",   name:"èŠ±åª½",    prob:0.20, score:+3,   grow:+2,   isPositive:true, isEgg:true },
    { key:"ANGRY", name:"ç”Ÿæ°£é¹¿é¹¿", prob:0.20, score:-3,  shrink:2,  isPositive:false, isMine:true },
  ];
  function pickItemByProb(){
    const r = Math.random();
    let acc = 0;
    for (const it of ITEM_DEFS){
      acc += it.prob;
      if (r <= acc) return it;
    }
    return ITEM_DEFS[0];
  }

  /***********************
   * åˆ†å±¤åˆ·æ–°æ§åˆ¶ï¼ˆä½ è¦çš„æ´»å‹•æ„Ÿï¼‰
   ***********************/
  let lastMomSpawnAt = -1e15;
  let lastAngrySpawnAt = -1e15;

  const MOM_MIN_GAP_MS = 15000;   // èŠ±åª½è‡³å°‘ 15 ç§’æ‰å‡ºä¸€æ¬¡
  const ANGRY_MIN_GAP_MS = 5500;  // åœ°é›·è‡³å°‘ 5.5 ç§’æ‰å‡ºä¸€æ¬¡ï¼ˆç·Šå¼µä½†å¯æ§ï¼‰
  const ANGRY_SAFE_RADIUS = 5;    // åœ°é›·é›¢è›‡é ­è‡³å°‘ 5 æ ¼
  const MOM_WARN_MS = 1000;       // èŠ±åª½å‡ºç¾å‰ 1 ç§’é–ƒå…‰é å‘Š

  // é™æ™‚åŠ æˆåœˆï¼ˆ60ç§’å¾Œï¼‰
  const BOOST_AFTER_MS = 60000;
  const BOOST_TTL_MS = 9000;
  const BOOST_COOLDOWN_MS = 12000;
  const BOOST_DOUBLE_MS = 3000;
  let boost = null;               // {x,y,bornAt,ttlMs}
  let lastBoostSpawnAt = -1e15;
  let doubleUntil = 0;

  /***********************
   * éŠæˆ²ç‹€æ…‹
   ***********************/
  let running = false;
  let dir = {x:1,y:0};
  let nextDir = {x:1,y:0};

  let snake = [];
  const INIT_LEN = 1;

  // targets: çœŸæ­£å¯åƒçš„ç‰©ä»¶
  let targets = [];
  // warns: èŠ±åª½é å‘Šé–ƒå…‰ï¼ˆä¸å¯åƒï¼‰ï¼Œæ™‚é–“åˆ°æœƒè®Šæˆ MOM target
  let warns = []; // {x,y,spawnAt} spawnAt=é å‘Šé–‹å§‹æ™‚é–“

  let desiredCount = 1;
  let nextDesiredRecalcAt = 0;

  let pendingGrowth = 0;
  let score = 0;
  let best = Number(localStorage.getItem(BEST_KEY) || 0);
  $best.textContent = fmt(best);

  // streak
  let streak = 0;
  let lastPositiveEatAt = 0;

  // èŠ±åª½åŠ é€Ÿ
  const baseTickMs = 120;
  const MOM_SPEED_FACTOR = 1.7;
  const MOM_SPEED_MS = baseTickMs / MOM_SPEED_FACTOR; // ~70.6ms
  const MOM_BOOST_MS = 3000;
  let momBoostUntil = 0;

  let tickMs = baseTickMs;
  let tickHandle = null;
  let gameStartAt = 0;

  const elapsedMs = ()=> running ? (Date.now() - gameStartAt) : 0;

  function chebyshevDist(ax, ay, bx, by){
    return Math.max(Math.abs(ax - bx), Math.abs(ay - by));
  }
  function tooCloseToHeadForAngry(x, y){
    const h = snake[0];
    if (!h) return false;
    return chebyshevDist(x, y, h.x, h.y) <= ANGRY_SAFE_RADIUS;
  }

  function multiplierLevel(){ return Math.floor(streak / 10); }
  function scoreMultiplier(){ return 1 + multiplierLevel() * 0.25; } // x1.25/x1.5/...

  function speedFactorFromStreak(){
    const micro = 1 + Math.min(0.20, streak * 0.01);
    const lv = multiplierLevel();
    const tier = (lv >= 1) ? (1 + (0.10 * lv + 0.10)) : 1; // 1.2/1.3/1.4...
    return micro * tier;
  }

  // ç·Šå¼µä½†å¯æ§ï¼šæ™‚é–“è¶Šä¹…ï¼ŒåŸºç¤é€Ÿåº¦è¶Šå¿«ï¼ˆ0~90ç§’é™åˆ° 92msï¼‰
  function effectiveTickMs(){
    const e = elapsedMs();
    const timeBoost = Math.min(1, e / 90000);
    const timeBaseMs = baseTickMs - (baseTickMs - 92) * timeBoost;

    const sf = speedFactorFromStreak();
    let ms = timeBaseMs / sf;

    if (Date.now() < momBoostUntil) ms = Math.min(ms, MOM_SPEED_MS);
    return clamp(ms, 55, 180);
  }

  function applyTickRate(){
    const newMs = effectiveTickMs();
    if (Math.abs(newMs - tickMs) < 0.5) return;
    tickMs = newMs;
    if (running){
      clearInterval(tickHandle);
      tickHandle = setInterval(tick, tickMs);
    }
  }

  function currentScoreFinalForUI(){
    const bonus = Math.max(0, snake.length - INIT_LEN);
    return score + bonus;
  }

  /***********************
   * ç‰©ä»¶æ•¸é‡ç¯€å¥ï¼ˆä½ æŒ‡å®šçš„æ™‚é–“æ®µï¼‰
   ***********************/
  function updateDesiredCount(){
    const e = elapsedMs();

    // æ¯ 3 ç§’æ‰é‡æ–°æŠ½ä¸€æ¬¡ï¼Œé¿å…ä¸€ç›´è·³
    if (Date.now() < nextDesiredRecalcAt) return;
    nextDesiredRecalcAt = Date.now() + 3000;

    let min=1, max=1;
    if (e < 20000) {          // 0â€“20
      min=1; max=1;
    } else if (e < 40000) {   // 20â€“40
      min=1; max=2;
    } else if (e < 60000) {   // 40â€“60
      min=2; max=3;
    } else {                  // 60+
      min=3; max=4;
    }
    desiredCount = min + Math.floor(Math.random() * (max - min + 1));
  }

  // åˆ·æ–°ç¯€å¥ï¼šè¶Šå¾ŒæœŸè¶Šå¿«
  function ttlForNow(){
    const e = elapsedMs();
    if (e < 20000) return randRange(11000, 15000);
    if (e < 40000) return randRange(10000, 14000);
    if (e < 60000) return randRange(9000, 13000);
    return randRange(7000, 10000);
  }

  function updateUI(){
    $score.textContent = fmt(score);
    $streak.textContent = String(Math.floor(streak));
    $mult.textContent = "x" + fmt(scoreMultiplier());
    $len.textContent = String(snake.length);

    const boosting = Date.now() < momBoostUntil;
    const sf = speedFactorFromStreak();
    const baseFast = (sf > 1.02);
    if (boosting) $spd.textContent = "èŠ±åª½åŠ é€Ÿä¸­";
    else if (baseFast) $spd.textContent = "é€£åƒåŠ é€Ÿä¸­";
    else $spd.textContent = "æ­£å¸¸";

    $liveItems.textContent = `${targets.length}${boost ? "+åœˆ" : ""}/${desiredCount}`;
    $x2Tag.style.display = (Date.now() < doubleUntil) ? "inline-flex" : "none";
  }

  function cellOccupied(x,y){
    if (snake.some(s => s.x===x && s.y===y)) return true;
    if (targets.some(t => t.x===x && t.y===y)) return true;
    if (warns.some(w => w.x===x && w.y===y)) return true;
    if (boost && boost.x===x && boost.y===y) return true;
    return false;
  }

  function randCell(){
    return { x: Math.floor(Math.random()*GRID), y: Math.floor(Math.random()*GRID) };
  }

  /***********************
   * åˆ†å±¤åˆ·æ–°ï¼šç”Ÿæˆä¸€å€‹ targetï¼ˆå¯èƒ½æœƒå…ˆç”Ÿæˆ MOM é å‘Šï¼‰
   ***********************/
  function maxMinesNow(){
    const e = elapsedMs();
    // 60ç§’å¾Œåœ°é›·æ›´å¸¸è¦‹ï¼Œä½†ä»å¯æ§
    return (e < 60000) ? 1 : 2;
  }

  function canSpawnMom(now){
    return (now - lastMomSpawnAt) >= MOM_MIN_GAP_MS;
  }
  function canSpawnAngry(now){
    return (now - lastAngrySpawnAt) >= ANGRY_MIN_GAP_MS;
  }

  function tryPlaceAtSafeCell(predicate){
    for (let attempt=0; attempt<120; attempt++){
      let c = randCell();
      let tries = 0;
      while (cellOccupied(c.x,c.y) && tries < 500){
        c = randCell(); tries++;
      }
      if (cellOccupied(c.x,c.y)) continue;
      if (predicate && !predicate(c.x,c.y)) continue;
      return c;
    }
    return null;
  }

  function scheduleMomWarn(now){
    // æ‰¾ä½ç½®ï¼ˆä¸éœ€é¿é ­ï¼Œä½†é¿å…æ’è›‡/ç‰©ä»¶ï¼‰
    const c = tryPlaceAtSafeCell(() => true);
    if (!c) return false;
    warns.push({ x:c.x, y:c.y, spawnAt: now }); // 1 ç§’å¾Œè½‰ MOM
    lastMomSpawnAt = now; // å…ˆé–å®šå†·å»ï¼Œé¿å…é€£çºŒé å‘Š
    return true;
  }

  function spawnOneTarget(now){
    const e = elapsedMs();
    const minesOnField = targets.filter(t => t.def.key === "ANGRY").length;

    // 60ç§’å¾Œï¼šå¶çˆ¾é€£é–ç”Ÿæˆ 2 é¡†åœ°é›·ï¼ˆä¸é™°ï¼šé›¢é ­>=5ï¼Œä¸”ä¸è¶…éä¸Šé™ï¼‰
    const allowChainMine = (e >= 60000) && (Math.random() < 0.18); // å¶çˆ¾
    const maxMines = maxMinesNow();

    // å…ˆå˜—è©¦æŒ‰æ¬Šé‡æŠ½ defï¼Œä½†è¦ç¬¦åˆåˆ†å±¤è¦å‰‡
    for (let attempt=0; attempt<120; attempt++){
      let def = pickItemByProb();

      // èŠ±åª½ï¼šå¿…é ˆç¬¦åˆå†·å» -> æ”¹æˆã€Œå…ˆé–ƒå…‰ 1 ç§’ã€å†å‡ºç¾
      if (def.key === "MOM"){
        if (!canSpawnMom(now)) continue;
        // å…ˆæ’ç¨‹é å‘Šï¼ˆ1ç§’å¾ŒçœŸæ­£å‡ºç¾ï¼‰
        if (scheduleMomWarn(now)) return true;
        continue;
      }

      // åœ°é›·ï¼šå†·å» + åŒå ´ä¸Šé™ + é›¢é ­5æ ¼
      if (def.key === "ANGRY"){
        if (!canSpawnAngry(now)) continue;
        if (minesOnField >= maxMines) continue;

        const c = tryPlaceAtSafeCell((x,y)=> !tooCloseToHeadForAngry(x,y));
        if (!c) continue;

        targets.push({ x:c.x, y:c.y, def, bornAt: now, ttlMs: ttlForNow() });
        lastAngrySpawnAt = now;

        // é€£é– 2 é¡†ï¼ˆä»éœ€ä¸Šé™ + å®‰å…¨è·é›¢ï¼‰
        if (allowChainMine && targets.filter(t => t.def.key === "ANGRY").length < maxMines){
          // é€£é–çš„ç¬¬äºŒé¡†ä¸éœ€è¦é¡å¤–å†·å»ï¼Œä½†ä»é¿é ­/ä¸é‡ç–Š
          const c2 = tryPlaceAtSafeCell((x,y)=> !tooCloseToHeadForAngry(x,y));
          if (c2){
            targets.push({ x:c2.x, y:c2.y, def, bornAt: now, ttlMs: ttlForNow() });
            // é€£é–ç”Ÿæˆä¹Ÿæ›´æ–° lastAngrySpawnAtï¼Œé¿å…é¦¬ä¸Šåˆå‡º
            lastAngrySpawnAt = now;
          }
        }

        return true;
      }

      // ä¸€èˆ¬åŠ åˆ†ï¼ˆé˜¿æ°´/é¹¿çˆ¸ï¼‰
      const c = tryPlaceAtSafeCell(() => true);
      if (!c) continue;

      targets.push({ x:c.x, y:c.y, def, bornAt: now, ttlMs: ttlForNow() });
      return true;
    }

    // ä¿åº•ï¼šæ”¾é˜¿æ°´
    const safeDef = ITEM_DEFS.find(d => d.key === "ASHUI") || ITEM_DEFS[0];
    const c = tryPlaceAtSafeCell(() => true);
    if (!c) return false;
    targets.push({ x:c.x, y:c.y, def:safeDef, bornAt: now, ttlMs: ttlForNow() });
    return true;
  }

  /***********************
   * 60ç§’å¾Œï¼šé™æ™‚åŠ æˆåœˆï¼ˆx2 3ç§’ï¼‰
   ***********************/
  function maybeSpawnBoost(now){
    const e = elapsedMs();
    if (e < BOOST_AFTER_MS) return;
    if (boost) return;
    if ((now - lastBoostSpawnAt) < BOOST_COOLDOWN_MS) return;

    // æ©Ÿç‡ï¼šè¶Šå¾ŒæœŸç•¥æé«˜ï¼ˆç·Šå¼µä½†å¯æ§ï¼‰
    const p = clamp(0.05 + Math.min(0.05, (e-BOOST_AFTER_MS)/120000*0.05), 0.05, 0.10);
    if (Math.random() > p) return;

    const c = tryPlaceAtSafeCell(() => true);
    if (!c) return;
    boost = { x:c.x, y:c.y, bornAt: now, ttlMs: BOOST_TTL_MS };
    lastBoostSpawnAt = now;
  }

  /***********************
   * ç¶­æŒç›®æ¨™ï¼šéæœŸä¸æ¶ˆå¤± -> æ›ä½ç½®/æ›è§’è‰²
   ***********************/
  function rerollTarget(t, now){
    // é‡æŠ½ defï¼ˆéµå®ˆåˆ†å±¤ï¼šå¯èƒ½è½‰æˆ MOM é å‘Šï¼‰
    // å…ˆæŠŠåŸæœ¬ä½ç½®é‡‹æ”¾ï¼šåšæ³•æ˜¯å…ˆæš«æ™‚æŠŠå®ƒç§»é™¤ï¼Œå†é‡æ–°ç”Ÿæˆ
    const idx = targets.indexOf(t);
    if (idx >= 0) targets.splice(idx, 1);

    // é‡æ–°ç”Ÿæˆä¸€å€‹ï¼ˆå¯èƒ½æ˜¯ MOM é å‘Šæˆ–ä¸€èˆ¬ç‰©ä»¶ï¼‰
    const ok = spawnOneTarget(now);
    if (!ok){
      // ç”Ÿæˆå¤±æ•—å°±æŠŠåŸæœ¬å¡å›å»ï¼ˆæ¥µç«¯ä¿åº•ï¼‰
      targets.push(t);
    }
  }

  function maintainAll(){
    const now = Date.now();

    updateDesiredCount();

    // 1) èŠ±åª½é å‘Šï¼šåˆ° 1 ç§’å°±è½‰æˆ MOM target
    if (warns.length){
      const keep = [];
      for (const w of warns){
        if (now - w.spawnAt >= MOM_WARN_MS){
          // è½‰ MOM target
          const def = ITEM_DEFS.find(d => d.key === "MOM");
          if (def && !cellOccupied(w.x,w.y)){
            targets.push({ x:w.x, y:w.y, def, bornAt: now, ttlMs: ttlForNow() });
            // MOM ç”Ÿæˆä¸ç®—åœ°é›·ï¼Œä¸ç”¨å®‰å…¨è·é›¢ï¼›å·²ç¶“é–å†·å»
            sfxBeep(880, 0.05, "square", 0.10); // å°æç¤ºéŸ³ï¼ˆä¸æœƒå¤ªåµï¼‰
          }
        } else {
          keep.push(w);
        }
      }
      warns = keep;
    }

    // 2) boostï¼šéæœŸæ”¹æˆæ›ä½ç½®ï¼ˆä¸æ¶ˆå¤±ï¼‰
    if (boost){
      if ((now - boost.bornAt) > boost.ttlMs){
        const c = tryPlaceAtSafeCell(() => true);
        if (c){
          boost.x = c.x; boost.y = c.y;
          boost.bornAt = now;
          boost.ttlMs = BOOST_TTL_MS;
        } else {
          // æ‰¾ä¸åˆ°å°±å»¶é•·é¿å…å¡æ­»
          boost.bornAt = now;
          boost.ttlMs = BOOST_TTL_MS;
        }
      }
    } else {
      maybeSpawnBoost(now);
    }

    // 3) targetsï¼šéæœŸå°±ã€Œæ›ä½ç½®/æ›è§’è‰²ã€
    for (const t of [...targets]){
      if ((now - t.bornAt) > t.ttlMs){
        rerollTarget(t, now);
      }
    }

    // 4) è£œåˆ° desiredCountï¼ˆæ³¨æ„ï¼šMOM é å‘Šç®—â€œå°‡è¦å‡ºç¾â€ï¼Œä½†ä¸ç®—ç›®å‰ targetsï¼Œæ‰€ä»¥ä»è£œ targetsï¼‰
    while (targets.length < desiredCount){
      spawnOneTarget(now);
      // é˜²å‘†ï¼šå¦‚æœä¸€ç›´ç”Ÿä¸å‡ºï¼Œé¿å…æ­»å¾ªç’°
      if (targets.length > desiredCount + 2) break;
    }

    // 5) è‹¥è¶…éï¼ˆä¿åº•ç¸®å›ï¼‰
    while (targets.length > desiredCount){
      targets.pop();
    }
  }

  /***********************
   * åƒåˆ°ç‰©ä»¶ï¼ˆå« x2ï¼‰
   ***********************/
  function applyDoubleMultiplier(val){
    return (Date.now() < doubleUntil) ? (val * 2) : val;
  }

  function onEat(def){
    if (def.isPositive){
      streak += 1;
      lastPositiveEatAt = Date.now();

      const mult = scoreMultiplier();
      const baseAdd = (def.score || 0) * mult;
      score += applyDoubleMultiplier(baseAdd);

      pendingGrowth += (def.grow || 0);

      // éŸ³æ•ˆï¼šé€£åƒéŸ³é«˜
      const pitch = 520 + Math.min(30, Math.floor(streak)) * 18;
      sfxBeep(pitch, 0.06, "sine", 0.18);
      sfxBeep(pitch * 1.18, 0.04, "triangle", 0.12);

      // èŠ±åª½ï¼šåŠ é€Ÿ 3 ç§’ï¼ˆ1.7xï¼‰ï¼‹ç‰¹æ®ŠéŸ³æ•ˆ
      if (def.isEgg){
        momBoostUntil = Date.now() + MOM_BOOST_MS;
        sfxBeep(988, 0.07, "square", 0.20);
        sfxBeep(1319, 0.09, "square", 0.18);
        sfxBeep(1760, 0.11, "triangle", 0.14);
      }
    } else {
      // åœ°é›·ï¼šä¸­æ–·é€£åƒã€é€Ÿåº¦é‡ç½®ï¼ˆä¹Ÿå–æ¶ˆèŠ±åª½åŠ é€Ÿï¼‰
      streak = 0;
      lastPositiveEatAt = 0;
      momBoostUntil = 0;

      score += (def.score || 0);

      const shrink = def.shrink || 0;
      pendingGrowth = 0;
      for (let i=0; i<shrink; i++){
        if (snake.length > INIT_LEN) snake.pop();
      }

      sfxBeep(160, 0.09, "sawtooth", 0.22);
      sfxBeep(120, 0.11, "sawtooth", 0.20);
    }

    applyTickRate();
    updateUI();
  }

  function onEatBoost(){
    // x2 3 ç§’ï¼ˆä¸åŠ é•·ã€ä¸ç®—æ‰£åˆ†ï¼‰
    doubleUntil = Date.now() + BOOST_DOUBLE_MS;
    sfxBeep(740, 0.06, "triangle", 0.14);
    sfxBeep(988, 0.08, "triangle", 0.14);
    sfxBeep(1319, 0.10, "triangle", 0.12);

    // åƒåˆ°å¾ŒæŠŠåœˆç§»èµ°ï¼Œç¨å¾Œå†ç”Ÿæˆï¼ˆcooldown ç”± lastBoostSpawnAt æ§åˆ¶ï¼‰
    boost = null;

    // ç®—ã€ŒåŠ åˆ†äº‹ä»¶ã€ï¼šç®—é€£åƒ+1 ä½†ä¸åŠ åˆ†ï¼Œè®“ç©å®¶æ›´æƒ³å»åƒ
    streak += 1;
    lastPositiveEatAt = Date.now();

    applyTickRate();
    updateUI();
  }

  /***********************
   * éŠæˆ²è¿´åœˆ
   ***********************/
  function tick(){
    if (!running) return;

    // é€£åƒè¡°æ¸›ï¼šè¶…é 3 ç§’æ²’åƒåˆ°åŠ åˆ†é …ç›®æ‰ä¸‹é™
    if (streak > 0 && lastPositiveEatAt > 0 && (Date.now() - lastPositiveEatAt >= 3000)) {
      streak = Math.max(0, streak - 0.35);
    }

    // ç¶­æŒç‰©ä»¶ï¼ˆå«ï¼šéæœŸæ›ä½/æ›è§’ã€èŠ±åª½é å‘Šè½‰æ­£ã€x2åœˆï¼‰
    maintainAll();

    dir = nextDir;
    const head = snake[0];
    const newHead = { x: head.x + dir.x, y: head.y + dir.y };

    // æ’ç‰†
    if (newHead.x < 0 || newHead.y < 0 || newHead.x >= GRID || newHead.y >= GRID){
      gameOver("æ’åˆ°ç‰†");
      return;
    }
    // æ’è‡ªå·±
    if (snake.some((s,i)=> i!==0 && s.x===newHead.x && s.y===newHead.y)){
      gameOver("æ’åˆ°è‡ªå·±");
      return;
    }

    snake.unshift(newHead);

    // å…ˆæª¢æŸ¥åƒåˆ° x2 åœˆï¼ˆå„ªå…ˆè™•ç†ï¼‰
    if (boost && newHead.x === boost.x && newHead.y === boost.y){
      onEatBoost();
    }

    // æª¢æŸ¥åƒåˆ°ä»»ä¸€ target
    const hitIndex = targets.findIndex(t => t.x === newHead.x && t.y === newHead.y);
    if (hitIndex >= 0){
      const t = targets[hitIndex];
      onEat(t.def);
      targets.splice(hitIndex, 1);
      // åƒæ‰å¾Œç«‹åˆ»è£œé‡ï¼ˆç¶­æŒç¯€å¥ï¼‰
      maintainAll();
    }

    // æˆé•·ï¼ˆæ”¯æ´ 1.5ï¼‰
    if (pendingGrowth >= 1){
      pendingGrowth -= 1;
    } else {
      snake.pop();
    }

    applyTickRate();
    updateUI();
    draw();
  }

  function gameOver(reason="æ’åˆ°ç‰†æˆ–è‡ªå·±"){
    running = false;
    clearInterval(tickHandle); tickHandle = null;

    sfxBeep(220, 0.10, "sawtooth", 0.22);
    sfxBeep(196, 0.12, "sawtooth", 0.18);

    const bonus = Math.max(0, snake.length - INIT_LEN);
    const finalScore = score + bonus;

    if (finalScore > best){
      best = finalScore;
      localStorage.setItem(BEST_KEY, String(best));
      $best.textContent = fmt(best);
    }

    const avaUrl = pickRandomAva();
    const top10 = addScoreToBoard({ name: playerName, score: finalScore, at: Date.now(), avaUrl });

    openModal({
      title: "éŠæˆ²çµæŸï¼",
      sub: `åŸå› ï¼š${reason}ã€€ï½œã€€çµæŸåŠ æˆï¼šèº«é«”å¤š ${bonus} æ ¼ +${bonus} åˆ†`,
      text:
`ä½ çš„æœ€çµ‚åˆ†æ•¸ï¼š<b>${fmt(finalScore)}</b><br/>
ï¼ˆå³æ™‚åˆ†æ•¸ï¼š${fmt(score)} ï¼‹ é•·åº¦åŠ æˆï¼š${fmt(bonus)}ï¼‰`,
      score: finalScore,
      showRank: true,
      showAgain: true,
      rankData: top10,
      avaUrl
    });
  }

  btnAgain.addEventListener("click", () => {
    closeModal();
    resetGame();
    startGame();
  });
  btnGo.addEventListener("click", () => {
    closeModal();
    resetGame();
    startGame();
  });

  /***********************
   * ç¹ªåœ–
   ***********************/
  function drawGridGlow(){
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1;
    for(let i=1;i<GRID;i++){
      ctx.beginPath(); ctx.moveTo(i*CELL,0); ctx.lineTo(i*CELL,cv.height); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,i*CELL); ctx.lineTo(cv.width,i*CELL); ctx.stroke();
    }
    ctx.restore();
  }

  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function drawBody(seg, idx){
    const x = seg.x * CELL, y = seg.y * CELL;
    ctx.save();
    ctx.fillStyle = (idx % 2 === 0) ? "#ffd98a" : "#ffe29a";
    roundRect(x+2,y+2,CELL-4,CELL-4,8);
    ctx.fill();

    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "#d0892d";
    [[x+7,y+8],[x+14,y+11],[x+10,y+16]].forEach(([sx,sy])=>{
      ctx.beginPath();
      ctx.ellipse(sx, sy, 3.1, 2.6, 0, 0, Math.PI*2);
      ctx.fill();
    });
    ctx.restore();
  }

  function drawHead(seg){
    const img = SPR.HEAD;
    const x = seg.x * CELL, y = seg.y * CELL;

    ctx.save();
    ctx.fillStyle = "#ffe29a";
    roundRect(x+2,y+2,CELL-4,CELL-4,8);
    ctx.fill();
    ctx.restore();

    if (!img) return;

    let ang = 0;
    if (dir.x === 1) ang = 0;
    if (dir.x === -1) ang = Math.PI;
    if (dir.y === 1) ang = Math.PI/2;
    if (dir.y === -1) ang = -Math.PI/2;

    const cx = x + CELL/2;
    const cy = y + CELL/2;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(ang);

    const size = CELL * HEAD_SCALE;
    ctx.drawImage(img, -size/2, -size/2, size, size);
    ctx.restore();
  }

  function drawTarget(t){
    const def = t.def;
    const img = SPR[def.key] || null;
    const x = t.x * CELL, y = t.y * CELL;

    ctx.save();
    if (def.isEgg){
      ctx.shadowColor = "rgba(255,200,0,.55)";
      ctx.shadowBlur = 18;
    } else if (def.isMine){
      ctx.shadowColor = "rgba(255,60,60,.55)";
      ctx.shadowBlur = 18;
    } else {
      ctx.shadowColor = "rgba(255,120,190,.35)";
      ctx.shadowBlur = 12;
    }

    const size = CELL * TARGET_SCALE;
    const ox = x + (CELL - size) / 2;
    const oy = y + (CELL - size) / 2;

    if (img) ctx.drawImage(img, ox, oy, size, size);
    else {
      ctx.fillStyle = def.isMine ? "#ff4d4f" : (def.isEgg ? "#ffd24d" : "#ff5aa5");
      ctx.beginPath();
      ctx.arc(x+CELL/2, y+CELL/2, CELL*0.38, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawMomWarn(w){
    const x = w.x * CELL, y = w.y * CELL;
    const blink = Math.sin((Date.now() - w.spawnAt) / 80) > 0 ? 1 : 0.35;

    ctx.save();
    ctx.globalAlpha = 0.85 * blink;
    ctx.shadowColor = "rgba(255,215,0,.9)";
    ctx.shadowBlur = 22;
    ctx.strokeStyle = "rgba(255,215,0,.95)";
    ctx.lineWidth = 4;
    roundRect(x+3, y+3, CELL-6, CELL-6, 10);
    ctx.stroke();

    ctx.globalAlpha = 0.9 * blink;
    ctx.fillStyle = "rgba(255,215,0,.18)";
    roundRect(x+3, y+3, CELL-6, CELL-6, 10);
    ctx.fill();
    ctx.restore();
  }

  function drawBoost(b){
    const x = b.x * CELL, y = b.y * CELL;
    const t = Date.now() - b.bornAt;
    const pulse = 0.5 + 0.5*Math.sin(t/180);

    ctx.save();
    ctx.shadowColor = "rgba(90,200,255,.75)";
    ctx.shadowBlur = 22;

    ctx.globalAlpha = 0.95;
    ctx.strokeStyle = "rgba(90,200,255,.95)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(x+CELL/2, y+CELL/2, CELL*0.38 + pulse*2, 0, Math.PI*2);
    ctx.stroke();

    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(90,200,255,.25)";
    ctx.beginPath();
    ctx.arc(x+CELL/2, y+CELL/2, CELL*0.32 + pulse*2, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(255,255,255,.9)";
    ctx.font = `900 ${Math.floor(CELL*0.36)}px system-ui`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("x2", x+CELL/2, y+CELL/2);

    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);
    ctx.fillStyle = "#0b0b0f";
    ctx.fillRect(0,0,cv.width,cv.height);

    drawGridGlow();

    // å…ˆç•«ç‰¹æ•ˆï¼ˆé å‘Šã€åŠ æˆåœˆï¼‰å†ç•«å¯åƒç‰©ä»¶
    warns.forEach(drawMomWarn);
    if (boost) drawBoost(boost);
    targets.forEach(drawTarget);

    // snake
    for (let i=snake.length-1; i>=1; i--) drawBody(snake[i], i);
    drawHead(snake[0]);

    if (!running){
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.font = "bold 18px system-ui, -apple-system";
      ctx.textAlign = "center";
      ctx.fillText("æŒ‰ã€Œé–‹å§‹ã€æˆ–æ»‘å‹•/æ–¹å‘éµé–‹å§‹", cv.width/2, cv.height/2 - 10);
      ctx.font = "13px system-ui, -apple-system";
      ctx.fillStyle = "rgba(255,255,255,.7)";
      ctx.fillText("èŠ±åª½æœƒå…ˆé–ƒå…‰1ç§’å†å‡ºç¾ï¼›60ç§’å¾Œæœƒå‡º x2 åŠ æˆåœˆ", cv.width/2, cv.height/2 + 14);
      ctx.restore();
    }
  }

  /***********************
   * è¼¸å…¥
   ***********************/
  function setDir(nx, ny){
    if (snake.length > 1 && nx === -dir.x && ny === -dir.y) return;
    nextDir = {x:nx, y:ny};
  }

  document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowUp") setDir(0,-1);
    if (e.key === "ArrowDown") setDir(0,1);
    if (e.key === "ArrowLeft") setDir(-1,0);
    if (e.key === "ArrowRight") setDir(1,0);
    if (!running && ["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) startGame();
  });

  function bindPad(id, nx, ny){
    const el = document.getElementById(id);
    el.addEventListener("pointerdown", (ev) => {
      ev.preventDefault();
      setDir(nx, ny);
      if (!running) startGame();
    });
  }
  bindPad("up", 0, -1);
  bindPad("down", 0, 1);
  bindPad("left", -1, 0);
  bindPad("right", 1, 0);

  let sx=0, sy=0, st=0;
  cv.addEventListener("touchstart", (e) => {
    const t = e.touches[0];
    sx = t.clientX; sy = t.clientY; st = Date.now();
  }, {passive:true});

  cv.addEventListener("touchend", (e) => {
    const t = e.changedTouches[0];
    const dxT = t.clientX - sx;
    const dyT = t.clientY - sy;
    const dt = Date.now() - st;
    if (dt > 500) return;
    if (Math.abs(dxT) < 18 && Math.abs(dyT) < 18) return;

    if (Math.abs(dxT) > Math.abs(dyT)) setDir(dxT > 0 ? 1 : -1, 0);
    else setDir(0, dyT > 0 ? 1 : -1);

    if (!running) startGame();
  });

  /***********************
   * æŒ‰éˆ•ï¼šé–‹å§‹ / ç©æ³•
   ***********************/
  document.getElementById("btnStart").addEventListener("click", () => {
    if (!snake.length) resetGame();
    startGame();
  });

  document.getElementById("btnHow").addEventListener("click", () => {
    const rule =
`ã€å‡ºç¾æ©Ÿç‡ / åˆ†æ•¸ / èº«é«”è®ŠåŒ–ã€‘
â€¢ é˜¿æ°´ 35%ï¼š+1 åˆ†ï¼Œèº«é«” +1
â€¢ é¹¿çˆ¸ 25%ï¼š+1.5 åˆ†ï¼Œèº«é«” +1.5
â€¢ èŠ±åª½ 20%ï¼ˆå½©è›‹ï¼‰ï¼š+3 åˆ†ï¼Œèº«é«” +2ï¼Œé€Ÿåº¦ 1.7 å€åŠ é€Ÿ 3 ç§’ï¼ˆç‰¹æ®ŠéŸ³æ•ˆï¼‰
  â€» èŠ±åª½å‡ºç¾å‰æœƒå…ˆã€Œé–ƒå…‰ 1 ç§’ã€é å‘Š
â€¢ ç”Ÿæ°£é¹¿é¹¿ 20%ï¼ˆåœ°é›·ï¼‰ï¼š-3 åˆ†ï¼Œèº«é«” -2ï¼ˆæœ€ä½ä¸å°æ–¼åˆå§‹é•·åº¦ 1ï¼‰ï¼Œä¸¦ä¸­æ–·é€£åƒã€é€Ÿåº¦é‡ç½®
  â€» åœ°é›·ä¸æœƒç”Ÿæˆåœ¨è›‡é ­ 5 æ ¼å…§ï¼ˆé˜²å¤ªé™°ï¼‰
  â€» 60 ç§’å¾Œã€Œå¶çˆ¾é€£é–ç”Ÿæˆ 2 é¡†ã€ï¼ˆä»éµå®ˆé›¢é ­ 5 æ ¼ & åŒå ´ä¸Šé™ï¼‰

ã€é€£åƒ streakã€‘
1) åƒåˆ°ã€ŒåŠ åˆ†é …ç›®ã€streak +1ï¼›åƒåˆ°æ‰£åˆ†é …ç›® = ä¸­æ–·ï¼ˆæ­¸ 0ï¼‰
2) é€£çºŒåƒåˆ°åŠ åˆ†é …ç›®æ‰æœƒæŒçºŒå¾®å¹…åŠ é€Ÿ + éŸ³æ•ˆéŸ³é«˜ä¸Šå‡
3) è¶…é 3 ç§’æ²’åƒåˆ°åŠ åˆ†é …ç›®ï¼Œstreak æœƒç·©æ…¢ä¸‹é™ï¼ˆæ¯ tick ç´„ -0.35ï¼‰
4) streak é” 10/20/30...ï¼š
   â€¢ å€ç‡ x1.25 / x1.5 / x1.75 ...ï¼ˆåªä¹˜åœ¨ã€ŒåŠ åˆ†é …ç›®ã€å¾—åˆ†ï¼‰
   â€¢ é€Ÿåº¦é¡å¤– +20% / +30% / +40% ...
5) éŠç©æ™‚é–“è¶Šä¹…ï¼Œæ•´é«”åŸºç¤é€Ÿåº¦æœƒé€æ­¥æå‡ï¼ˆç·Šå¼µä½†å¯æ§ï¼‰

ã€å¤šç‰©ä»¶ç¯€å¥ã€‘
â€¢ 0â€“20 ç§’ï¼šå›ºå®š 1 ç‰©ä»¶ï¼ˆä¸Šæ‰‹ï¼‰
â€¢ 20â€“40 ç§’ï¼š1â€“2 ç‰©ä»¶
â€¢ 40â€“60 ç§’ï¼š2â€“3 ç‰©ä»¶
â€¢ 60 ç§’å¾Œï¼š3â€“4 ç‰©ä»¶ + æ›´å¿«åˆ·æ–°
â€» ç‰©ä»¶ã€ŒéæœŸã€ä¸æ¶ˆå¤±ï¼Œæœƒæ›ä½ç½®/æ›è§’è‰²ç¶­æŒæ´»å‹•æ„Ÿ

ã€60 ç§’å¾Œï¼šé™æ™‚åŠ æˆåœˆã€‘
åœ°åœ–æœƒå‡ºç¾ã€Œx2 åŠ æˆåœˆã€ï¼Œåƒåˆ°å¾Œã€Œåˆ†æ•¸ x2 æŒçºŒ 3 ç§’ã€ï¼ˆåªå½±éŸ¿åŠ åˆ†é …ç›®å¾—åˆ†ï¼‰

ã€çµæŸåŠ æˆã€‘
æ¯å¤šä¸€æ ¼èº«é«” +1 åˆ†ï¼ˆä»¥åˆå§‹é•·åº¦ 1 ç‚ºåŸºæº–ï¼‰`;

    openModal({
      title: "ç©æ³•èˆ‡åŠ æ¸›åˆ†èªªæ˜",
      sub: "ç·Šå¼µä½†å¯æ§ï¼šè¶Šç©è¶Šåˆºæ¿€",
      text: rule,
      score: currentScoreFinalForUI(),
      showRank: false,
      showClear: false,
      avaUrl: pickRandomAva()
    });
  });

  /***********************
   * é–‹å§‹å‰é®ç½©ï¼ˆå«ä½ è¦çš„èªªæ˜ï¼‰
   ***********************/
  function showStartIntro(){
    openModal({
      title: "æº–å‚™é–‹å§‹ï¼",
      sub: "é˜¿é¹¿é¹¿æ–‡å‰µ-è²ªé£Ÿé¹¿(åƒé¹¿ç²‰)",
      text:
`å‰ 20 ç§’å›ºå®š 1 ç‰©ä»¶è®“ä½ ä¸Šæ‰‹ï¼›ä¹‹å¾Œç‰©ä»¶æ•¸é‡èˆ‡åˆ·æ–°é€Ÿåº¦æœƒé€æ­¥æå‡ã€‚<br/>
èŠ±åª½æ˜¯å½©è›‹ï¼šæœƒå…ˆã€Œé–ƒå…‰ 1 ç§’ã€é å‘Šï¼Œåƒåˆ° +3 åˆ†ã€èº«é«” +2ã€1.7 å€åŠ é€Ÿ 3 ç§’ã€‚<br/>
ç”Ÿæ°£é¹¿é¹¿æ˜¯åœ°é›·ï¼šæ‰£åˆ†ç¸®çŸ­ï¼ˆæœ€ä½ä¸å°æ–¼ 1ï¼‰ï¼Œä¸¦ä¸­æ–·é€£åƒï¼›ä¸”ä¸æœƒåœ¨è›‡é ­ 5 æ ¼å…§ç”Ÿæˆã€‚<br/>
60 ç§’å¾Œæœƒå‡ºç¾ã€Œx2 é™æ™‚åŠ æˆåœˆã€ï¼šåƒåˆ°å¾Œåˆ†æ•¸ x2 æŒçºŒ 3 ç§’ï¼ˆåªå½±éŸ¿åŠ åˆ†é …ç›®ï¼‰ã€‚`,
      score: 0,
      showGo: true,
      showRank: false,
      showClear: false,
      avaUrl: pickRandomAva()
    });
  }

  /***********************
   * Reset / Start
   ***********************/
  function resetGame(){
    running = false;
    clearInterval(tickHandle); tickHandle = null;

    dir = {x:1,y:0};
    nextDir = {x:1,y:0};

    snake = [{ x: Math.floor(GRID/2), y: Math.floor(GRID/2) }];
    pendingGrowth = 0;

    score = 0;
    streak = 0;
    lastPositiveEatAt = 0;

    momBoostUntil = 0;
    lastMomSpawnAt = -1e15;
    lastAngrySpawnAt = -1e15;

    boost = null;
    lastBoostSpawnAt = -1e15;
    doubleUntil = 0;

    targets = [];
    warns = [];

    desiredCount = 1;
    nextDesiredRecalcAt = 0;
    gameStartAt = 0;

    // åˆå§‹è£œä¸€å€‹ç‰©ä»¶
    updateDesiredCount();
    maintainAll();

    applyTickRate();
    updateUI();
    draw();
  }

  function startGame(){
    if (running) return;
    running = true;
    gameStartAt = Date.now();
    nextDesiredRecalcAt = 0;

    ensureAudio();
    if (audioCtx.state === "suspended") audioCtx.resume();
    if ($bgmOn.checked) startBGM();

    maintainAll();
    applyTickRate();
    clearInterval(tickHandle);
    tickHandle = setInterval(tick, tickMs);
  }

  /***********************
   * åˆå§‹åŒ–
   ***********************/
  preload().finally(() => {
    resetGame();
    draw();
    showStartIntro();
  });

})();
</script>
</body>
</html>
