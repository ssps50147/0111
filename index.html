<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>é˜¿é¹¿é¹¿æ–‡å‰µ-è²ªé£Ÿé¹¿(åƒé¹¿ç²‰)</title>

  <style>
    :root{
      --bg1:#ffd6e7;
      --bg2:#fff4f9;
      --card:#ffffffcc;
      --text:#111;
      --shadow: rgba(0,0,0,.12);
      --safeT: env(safe-area-inset-top);
      --safeB: env(safe-area-inset-bottom);
    }
    html,body{height:100%; margin:0;}
    body{
      font-family: system-ui,-apple-system,"Segoe UI","Noto Sans TC","PingFang TC","Microsoft JhengHei",sans-serif;
      background: linear-gradient(180deg,var(--bg1),var(--bg2));
      color: var(--text);
      display:flex;
      justify-content:center;
    }
    .wrap{
      width:min(620px, 100%);
      padding: calc(12px + var(--safeT)) 12px calc(12px + var(--safeB));
      box-sizing:border-box;
    }
    .topbar{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border-radius:16px;
      background: var(--card);
      box-shadow: 0 8px 20px var(--shadow);
      backdrop-filter: blur(8px);
    }
    .title{display:flex; flex-direction:column; gap:4px;}
    .title b{font-size:15px; line-height:1.1;}
    .title small{opacity:.75; line-height:1.1;}
    .pill{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; align-items:center;}
    .btn{
      border:0;
      padding:10px 12px;
      border-radius:14px;
      background:#111;
      color:#fff;
      font-weight:900;
      cursor:pointer;
      box-shadow: 0 8px 16px rgba(0,0,0,.12);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      white-space:nowrap;
    }
    .btn.secondary{
      background:#fff;
      color:#111;
      border:1px solid rgba(0,0,0,.12);
      box-shadow:none;
    }
    .tag{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px;
      border-radius:999px;
      background:#fff;
      border:1px solid rgba(0,0,0,.12);
      font-size:12px;
      font-weight:900;
      white-space:nowrap;
    }

    .row{display:flex; gap:12px; margin-top:12px; align-items:stretch; flex-wrap:wrap;}
    .panel{
      flex:1 1 280px;
      padding:12px;
      border-radius:16px;
      background: var(--card);
      box-shadow: 0 8px 20px var(--shadow);
      backdrop-filter: blur(8px);
    }
    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px 10px;
      align-items:center;
      font-size:13px;
    }
    .kv .v{font-weight:900;}
    .hint{font-size:12px; opacity:.75; margin-top:8px; line-height:1.45;}

    .gamebox{
      margin-top:12px;
      padding:12px;
      border-radius:20px;
      background: rgba(255,255,255,.68);
      box-shadow: 0 10px 26px rgba(0,0,0,.12);
    }
    canvas{
      width:100%;
      height:auto;
      border-radius:16px;
      background:#0b0b0f;
      touch-action:none;
      display:block;
    }
    .controls{
      margin-top:10px;
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
    }
    .pad{
      padding:12px 10px;
      border-radius:16px;
      border:1px solid rgba(0,0,0,.12);
      background:#fff;
      font-weight:900;
      text-align:center;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .pad:active{transform: translateY(1px);}

    .footer{
      margin-top:12px;
      font-size:12px;
      opacity:.7;
      text-align:center;
      line-height:1.45;
    }

    .toggleRow{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      margin-bottom:10px;
      flex-wrap:wrap;
    }
    .toggle{
      display:flex; align-items:center; gap:8px;
      font-size:12px; font-weight:900;
      white-space:nowrap;
    }
    .toggle input{transform: scale(1.15);}
    .slider{
      display:flex; align-items:center; gap:8px;
      font-size:12px; font-weight:900;
      white-space:nowrap;
    }
    .slider input[type="range"]{ width:130px; }

    .namebox{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:flex-end;
      flex-wrap:wrap;
    }
    .namebox input{
      flex: 1 1 160px;
      border:1px solid rgba(0,0,0,.15);
      border-radius:12px;
      padding:10px 12px;
      font-weight:900;
      outline:none;
      background:#fff;
    }

    /* Modal */
    .mask{
      position:fixed; inset:0;
      background: rgba(0,0,0,.48);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index:50;
    }
    .modal{
      width:min(620px, 100%);
      border-radius:18px;
      background:#fff;
      padding:14px;
      box-shadow: 0 20px 60px rgba(0,0,0,.35);
    }
    .modalHead{
      display:flex; gap:12px; align-items:center; justify-content:space-between;
    }
    .modalHeadLeft{
      display:flex; gap:12px; align-items:center;
      min-width:0;
    }
    .avatar{
      width:54px; height:54px;
      border-radius:14px;
      border:1px solid rgba(0,0,0,.12);
      background:#fff;
      object-fit:cover;
      flex: 0 0 auto;
    }
    .modal p{margin:0 0 10px; font-size:13px; opacity:.88; line-height:1.55;}
    .modal .actions{
      display:flex; gap:10px; justify-content:flex-end; margin-top:12px; flex-wrap:wrap;
    }
    .rank{
      margin-top:10px;
      border-top:1px dashed rgba(0,0,0,.15);
      padding-top:10px;
      font-size:13px;
    }
    .rank ol{margin:8px 0 0 0; padding:0; list-style:none;}
    .rank li{
      margin:8px 0;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:8px 10px;
      border-radius:14px;
      background: rgba(0,0,0,.04);
    }
    .rankLeft{
      display:flex; align-items:center; gap:10px;
      min-width:0;
    }
    .rankAva{
      width:36px; height:36px;
      border-radius:12px;
      border:1px solid rgba(0,0,0,.12);
      object-fit:cover;
      background:#fff;
      flex: 0 0 auto;
    }
    .rankName{
      font-weight:900;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width: 320px;
    }
    .rankScore{font-weight:900;}
  </style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="title">
      <b>é˜¿é¹¿é¹¿æ–‡å‰µ-è²ªé£Ÿé¹¿(åƒé¹¿ç²‰)</b>
      <small>
        ç©å®¶ï¼š<span id="playerName">Guest</span>ã€€ï½œã€€å€ç‡ï¼š<span id="mult">x1</span>
        <span id="x2Tag" class="tag" style="display:none; margin-left:8px;">x2 åŠ æˆä¸­</span>
      </small>
    </div>
    <div class="pill">
      <span class="tag">åˆ†æ•¸ <span id="score">1</span></span>
      <span class="tag">æœ€é«˜ <span id="best">0</span></span>
      <button class="btn secondary" id="btnRank">æŸ¥è©¢æ’è¡Œæ¦œ</button>
      <button class="btn secondary" id="btnHow">ç©æ³•</button>
      <button class="btn" id="btnStart">é–‹å§‹</button>
    </div>
  </div>

  <div class="row">
    <div class="panel">
      <div class="kv">
        <div>é€Ÿåº¦</div><div class="v" id="spd">æ­£å¸¸</div>
        <div>é€£åƒ</div><div class="v" id="streak">0</div>
        <div>å ´ä¸Šç‰©ä»¶</div><div class="v" id="liveItems">0/1</div>
        <div>èº«é«”é•·åº¦</div><div class="v" id="len">1</div>
      </div>
      <div class="hint">
        é€£çºŒåƒåˆ°åŠ åˆ†é …ç›®æœƒå¾®å¹…åŠ é€Ÿï¼›åƒåˆ°åœ°é›·æœƒä¸­æ–·ä¸¦é‡ç½®é€Ÿåº¦ã€‚<br/>
        è¶…é 3 ç§’æ²’åƒåˆ°åŠ åˆ†é …ç›®ï¼Œé€£åƒæœƒé–‹å§‹ç·©æ…¢ä¸‹é™ã€‚
      </div>
    </div>

    <div class="panel">
      <div class="toggleRow">
        <div class="toggle"><label><input type="checkbox" id="bgmOn" checked> BGM</label></div>
        <div class="slider">éŸ³é‡ <input id="bgmVol" type="range" min="0" max="100" value="35"></div>
      </div>
      <div class="toggleRow" style="margin-bottom:0;">
        <div class="toggle"><label><input type="checkbox" id="sfxOn" checked> éŸ³æ•ˆ</label></div>
        <div class="slider">éŸ³é‡ <input id="sfxVol" type="range" min="0" max="100" value="55"></div>
      </div>

      <div class="namebox" style="margin-top:10px;">
        <input id="nameInput" maxlength="12" placeholder="è¼¸å…¥æš±ç¨±ï¼ˆå¯é¸ï¼‰" />
        <button class="btn secondary" id="btnSetName">å¥—ç”¨</button>
      </div>

      <div class="hint">
        æ’è¡Œæ¦œä½¿ç”¨ LocalStorageï¼ˆå…å¾Œç«¯ï¼‰ã€‚<br/>
        LINE/iOS éœ€ç¬¬ä¸€æ¬¡é»æ“Šå¾Œæ‰å…è¨±æ’­æ”¾è²éŸ³ï¼ˆå·²è™•ç†ï¼‰ã€‚
      </div>
    </div>
  </div>

  <div class="gamebox">
    <canvas id="cv" width="576" height="576"></canvas>

    <div class="controls">
      <div class="pad" id="left">â¬…ï¸</div>
      <div class="pad" id="up">â¬†ï¸</div>
      <div class="pad" id="right">â¡ï¸</div>
      <div class="pad" id="down" style="grid-column: 2 / 3;">â¬‡ï¸</div>
    </div>
  </div>

  <div class="footer">
    ç‰©ä»¶ã€ŒéæœŸã€ä¸æ¶ˆå¤±ï¼Œæœƒæ”¹æˆã€Œæ›ä½ç½®/æ›è§’è‰²ã€ç¶­æŒæ´»å‹•æ„Ÿã€‚<br/>
    çµæŸåŠ æˆï¼šæ¯å¤šä¸€æ ¼èº«é«” +1 åˆ†ï¼ˆä»¥åˆå§‹é•·åº¦ 1 ç‚ºåŸºæº–ï¼‰ã€‚
  </div>
</div>

<!-- å…±ç”¨ Modal -->
<div class="mask" id="mask">
  <div class="modal">
    <div class="modalHead">
      <div class="modalHeadLeft">
        <img id="modalAva" class="avatar" alt="é¹¿é¹¿" />
        <div style="min-width:0;">
          <h3 id="modalTitle" style="margin:0 0 6px; font-size:16px;">æç¤º</h3>
          <div style="font-size:12px;opacity:.8;line-height:1.35;" id="modalSub"></div>
        </div>
      </div>
      <div>
        <span class="tag">åˆ†æ•¸ <span id="modalScore">1</span></span>
      </div>
    </div>

    <p id="modalText" style="margin-top:10px;"></p>

    <div class="rank" id="rankBox" style="display:none;">
      <b>ğŸ† æ’è¡Œæ¦œï¼ˆå‰ 6 åï½œè¿‘ 7 å¤©ï¼‰</b>
      <ol id="rankList"></ol>
    </div>

    <div class="actions">
      <button class="btn secondary" id="btnClose">é—œé–‰</button>
      <button class="btn secondary" id="btnClearRank" style="display:none;">æ¸…ç©ºæ’è¡Œæ¦œ</button>
      <button class="btn" id="btnGo" style="display:none;">é–‹å§‹éŠæˆ²</button>
      <button class="btn" id="btnAgain" style="display:none;">å†ç©ä¸€æ¬¡</button>
    </div>
  </div>
</div>

<script>
(() => {
  /***********************
   * åœ–ç‰‡ï¼šraw ç›´é€£
   ***********************/
  const URLS = {
    HEAD:  "https://raw.githubusercontent.com/z883662/Aruru/main/lulu1.png",
    ASHUI: "https://raw.githubusercontent.com/z883662/Aruru/main/lulu4.png",
    DAD:   "https://raw.githubusercontent.com/z883662/Aruru/main/lulu2.png",
    MOM:   "https://raw.githubusercontent.com/z883662/Aruru/main/lulu3.png",
    ANGRY: "https://raw.githubusercontent.com/z883662/Aruru/main/lulu5.png",
  };
  const LULU_POOL = [URLS.HEAD, URLS.DAD, URLS.MOM, URLS.ASHUI, URLS.ANGRY];
  const pickRandomAva = () => LULU_POOL[Math.floor(Math.random()*LULU_POOL.length)];

  /***********************
   * GRID / SCALE
   ***********************/
  const GRID = 18;
  const TARGET_SCALE = 1.45;
  const HEAD_SCALE   = 1.35;

  /***********************
   * åˆ†æ•¸ä¸‹é™ï¼šæœ€ä½ 1 åˆ†
   ***********************/
  const SCORE_FLOOR = 1;

  /***********************
   * æ’è¡Œæ¦œï¼šå‰ 6 åã€ä¿ç•™ 7 å¤©
   ***********************/
  const STORAGE_KEY = "aruru_snake_board_final_v4";
  const BEST_KEY = "aruru_snake_best_final_v4";
  const NAME_KEY = "aruru_snake_name_final_v4";
  const AUDIO_KEY = "aruru_snake_audio_final_v4";
  const LAST_SCORE_KEY = "aruru_snake_last_score_final_v4";

  const KEEP_DAYS = 7;
  const TOP_N = 6;
  const KEEP_MS = KEEP_DAYS * 24 * 60 * 60 * 1000;

  /***********************
   * Canvas
   ***********************/
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  const CELL = cv.width / GRID;

  /***********************
   * UI
   ***********************/
  const $playerName = document.getElementById("playerName");
  const $nameInput = document.getElementById("nameInput");
  const $score = document.getElementById("score");
  const $best = document.getElementById("best");
  const $spd = document.getElementById("spd");
  const $streak = document.getElementById("streak");
  const $mult = document.getElementById("mult");
  const $len = document.getElementById("len");
  const $liveItems = document.getElementById("liveItems");
  const $x2Tag = document.getElementById("x2Tag");

  // Modal
  const mask = document.getElementById("mask");
  const modalAva = document.getElementById("modalAva");
  const modalTitle = document.getElementById("modalTitle");
  const modalSub = document.getElementById("modalSub");
  const modalText = document.getElementById("modalText");
  const modalScore = document.getElementById("modalScore");
  const rankBox = document.getElementById("rankBox");
  const rankList = document.getElementById("rankList");
  const btnClose = document.getElementById("btnClose");
  const btnGo = document.getElementById("btnGo");
  const btnAgain = document.getElementById("btnAgain");
  const btnClearRank = document.getElementById("btnClearRank");

  const fmt = (n) => (Number(n)||0).toFixed(2).replace(/\.?0+$/,"");
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const randRange = (a,b)=>Math.floor(a + Math.random()*(b-a+1));

  function openModal({title, sub="", text="", score=0, showRank=false, showGo=false, showAgain=false, showClear=false, rankData=null, avaUrl=null}) {
    modalTitle.textContent = title;
    modalSub.textContent = sub;
    modalText.innerHTML = text.replace(/\n/g,"<br/>");
    modalScore.textContent = fmt(score);
    modalAva.src = avaUrl || pickRandomAva();

    rankBox.style.display = showRank ? "block" : "none";
    if (showRank) renderRank(rankData || loadBoard());

    btnGo.style.display = showGo ? "inline-flex" : "none";
    btnAgain.style.display = showAgain ? "inline-flex" : "none";
    btnClearRank.style.display = showClear ? "inline-flex" : "none";

    mask.style.display = "flex";
  }
  const closeModal = ()=> mask.style.display = "none";
  btnClose.addEventListener("click", closeModal);

  /***********************
   * åœ–ç‰‡é è¼‰ï¼ˆå«éŒ¯èª¤è­¦å‘Š + ç ´å¿«å–ï¼‰
   ***********************/
  const SPR = {};
  function loadImg(url){
    return new Promise((resolve) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => resolve(img);
      img.onerror = () => {
        console.warn("IMG LOAD FAIL:", url);
        resolve(null);
      };
      img.src = url + "?v=" + Date.now();
    });
  }
  async function preload() {
    for (const [k, url] of Object.entries(URLS)) SPR[k] = await loadImg(url);
    for (const url of LULU_POOL) await loadImg(url);
  }

  /***********************
   * ç©å®¶æš±ç¨±
   ***********************/
  let playerName = localStorage.getItem(NAME_KEY) || "Guest";
  $playerName.textContent = playerName;
  $nameInput.value = (playerName === "Guest") ? "" : playerName;

  document.getElementById("btnSetName").addEventListener("click", () => {
    const v = ($nameInput.value || "").trim().slice(0,12);
    playerName = v || "Guest";
    localStorage.setItem(NAME_KEY, playerName);
    $playerName.textContent = playerName;
    sfxBeep(660, 0.06, "triangle", 0.12);
  });

  /***********************
   * è²éŸ³ï¼šBGM/SFX + éŸ³é‡
   ***********************/
  const $bgmOn = document.getElementById("bgmOn");
  const $sfxOn = document.getElementById("sfxOn");
  const $bgmVol = document.getElementById("bgmVol");
  const $sfxVol = document.getElementById("sfxVol");

  let audioCtx = null;
  let master = null;
  let bgmGain = null;
  let sfxGain = null;
  let bgmTimer = null;

  function loadAudioPrefs(){
    try{
      const p = JSON.parse(localStorage.getItem(AUDIO_KEY) || "{}");
      if (typeof p.bgmOn === "boolean") $bgmOn.checked = p.bgmOn;
      if (typeof p.sfxOn === "boolean") $sfxOn.checked = p.sfxOn;
      if (typeof p.bgmVol === "number") $bgmVol.value = String(p.bgmVol);
      if (typeof p.sfxVol === "number") $sfxVol.value = String(p.sfxVol);
    } catch {}
  }
  function saveAudioPrefs(){
    localStorage.setItem(AUDIO_KEY, JSON.stringify({
      bgmOn: $bgmOn.checked,
      sfxOn: $sfxOn.checked,
      bgmVol: Number($bgmVol.value),
      sfxVol: Number($sfxVol.value),
    }));
  }
  loadAudioPrefs();

  function ensureAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    master = audioCtx.createGain();
    master.gain.value = 0.9;
    master.connect(audioCtx.destination);

    bgmGain = audioCtx.createGain();
    sfxGain = audioCtx.createGain();
    bgmGain.connect(master);
    sfxGain.connect(master);
    applyVolumes();
  }

  function applyVolumes(){
    if (!bgmGain || !sfxGain) return;
    const bgm = Number($bgmVol.value) / 100;
    const sfx = Number($sfxVol.value) / 100;
    bgmGain.gain.value = clamp(bgm,0,1) * 0.28;
    sfxGain.gain.value = clamp(sfx,0,1) * 0.9;
  }

  $bgmOn.addEventListener("change", () => { saveAudioPrefs(); if ($bgmOn.checked) startBGM(); else stopBGM(); });
  $sfxOn.addEventListener("change", saveAudioPrefs);
  $bgmVol.addEventListener("input", () => { applyVolumes(); saveAudioPrefs(); });
  $sfxVol.addEventListener("input", () => { applyVolumes(); saveAudioPrefs(); });

  function sfxBeep(freq, dur=0.08, type="sine", vol=0.18) {
    if (!$sfxOn.checked) return;
    ensureAudio();
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g);
    g.connect(sfxGain);
    o.start(t0);
    o.stop(t0 + dur + 0.03);
  }

  function startBGM() {
    if (!$bgmOn.checked) return;
    ensureAudio();
    stopBGM();

    const seq = [
      [392, 494, 587],
      [440, 554, 659],
      [349, 440, 523],
      [392, 494, 587],
    ];
    let step = 0;

    bgmTimer = setInterval(() => {
      if (!$bgmOn.checked || !audioCtx) return;
      const chord = seq[step % seq.length]; step++;

      chord.forEach((f, i) => {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "triangle";
        o.frequency.value = f * (i === 0 ? 0.5 : 1);
        o.connect(g);
        g.connect(bgmGain);

        const t = audioCtx.currentTime + i * 0.02;
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(0.22, t + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);

        o.start(t);
        o.stop(t + 0.22);
      });
    }, 520);
  }
  function stopBGM(){ if (bgmTimer) clearInterval(bgmTimer); bgmTimer = null; }

  function unlockAudio() {
    ensureAudio();
    if (audioCtx.state === "suspended") audioCtx.resume();
    if ($bgmOn.checked) startBGM();
    window.removeEventListener("pointerdown", unlockAudio);
    window.removeEventListener("touchstart", unlockAudio);
    window.removeEventListener("keydown", unlockAudio);
  }
  window.addEventListener("pointerdown", unlockAudio, {once:false});
  window.addEventListener("touchstart", unlockAudio, {once:false});
  window.addEventListener("keydown", unlockAudio, {once:false});

  /***********************
   * æ’è¡Œæ¦œï¼šåªä¿ç•™è¿‘ 7 å¤©ã€åªå–å‰ 6 å
   ***********************/
  function pruneAndNormalize(list){
    const now = Date.now();
    const fresh = (Array.isArray(list) ? list : [])
      .filter(x => x && typeof x.at === "number" && (now - x.at) <= KEEP_MS)
      .map(x => ({
        name: (x.name || "ç©å®¶").toString().slice(0,12),
        score: Number(x.score) || 0,
        at: Number(x.at) || now,
        avaUrl: x.avaUrl || ""
      }));
    fresh.sort((a,b)=> b.score - a.score);
    return fresh.slice(0, TOP_N);
  }

  function loadBoard(){
    try{
      const raw = JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
      const cleaned = pruneAndNormalize(raw);
      localStorage.setItem(STORAGE_KEY, JSON.stringify(cleaned));
      return cleaned;
    } catch {
      return [];
    }
  }
  function saveBoard(list){
    const cleaned = pruneAndNormalize(list);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(cleaned));
    return cleaned;
  }

  function addScoreToBoard(entry){
    const list = loadBoard();
    list.push(entry);
    return saveBoard(list);
  }
  function clearBoard(){ localStorage.removeItem(STORAGE_KEY); }

  function renderRank(list){
    const data = pruneAndNormalize(Array.isArray(list) ? list : loadBoard());
    rankList.innerHTML = "";
    data.slice(0,TOP_N).forEach((r, i) => {
      const li = document.createElement("li");
      const left = document.createElement("div");
      left.className = "rankLeft";

      const ava = document.createElement("img");
      ava.className = "rankAva";
      ava.src = r.avaUrl || pickRandomAva();
      ava.alt = "é¹¿é¹¿";

      const name = document.createElement("div");
      name.className = "rankName";
      name.textContent = `${i+1}. ${r.name || "ç©å®¶"}`;

      left.appendChild(ava);
      left.appendChild(name);

      const sc = document.createElement("div");
      sc.className = "rankScore";
      sc.textContent = fmt(r.score ?? 0);

      li.appendChild(left);
      li.appendChild(sc);
      rankList.appendChild(li);
    });
  }

  btnClearRank.addEventListener("click", () => {
    clearBoard();
    renderRank([]);
    sfxBeep(330, 0.08, "square", 0.18);
  });

  document.getElementById("btnRank").addEventListener("click", () => {
    openModal({
      title: "æ’è¡Œæ¦œ",
      sub: `å‰ ${TOP_N} åï½œè¿‘ ${KEEP_DAYS} å¤©æœ€ä½³æˆç¸¾`,
      text: "ï¼ˆæœ¬æ’è¡Œæ¦œå„²å­˜åœ¨ä½ çš„è£ç½® LocalStorageï¼‰",
      score: currentScoreFinalForUI(),
      showRank: true,
      showClear: true,
      avaUrl: pickRandomAva()
    });
  });

  /***********************
   * ç‰©ä»¶å®šç¾©
   ***********************/
  const ITEM_DEFS = [
    { key:"ASHUI", name:"é˜¿æ°´",     prob:0.35, score:+1,   grow:+1,   isPositive:true },
    { key:"DAD",   name:"é¹¿çˆ¸",     prob:0.25, score:+1.5, grow:+1.5, isPositive:true },
    { key:"MOM",   name:"èŠ±åª½",     prob:0.20, score:+3,   grow:+2,   isPositive:true, isEgg:true },
    { key:"ANGRY", name:"ç”Ÿæ°£é¹¿é¹¿", prob:0.20, score:-3,  shrink:2,  isPositive:false, isMine:true },
  ];
  const POSITIVE_DEFS = ITEM_DEFS.filter(d => d.isPositive);

  function pickItemByProb(){
    const r = Math.random();
    let acc = 0;
    for (const it of ITEM_DEFS){
      acc += it.prob;
      if (r <= acc) return it;
    }
    return ITEM_DEFS[0];
  }
  function pickPositiveDef(){
    const sum = POSITIVE_DEFS.reduce((a,d)=>a+d.prob,0) || 1;
    let r = Math.random() * sum;
    for (const d of POSITIVE_DEFS){
      r -= d.prob;
      if (r <= 0) return d;
    }
    return POSITIVE_DEFS[0];
  }

  /***********************
   * åˆ·æ–°æ§åˆ¶
   ***********************/
  let lastMomSpawnAt = -1e15;
  let lastAngrySpawnAt = -1e15;

  const MOM_MIN_GAP_MS = 15000;
  const ANGRY_MIN_GAP_MS = 5500;
  const ANGRY_SAFE_RADIUS = 5;
  const MOM_WARN_MS = 1000;

  // x2 åŠ æˆåœˆï¼ˆ60ç§’å¾Œï¼‰
  const BOOST_AFTER_MS = 60000;
  const BOOST_TTL_MS = 9000;
  const BOOST_COOLDOWN_MS = 12000;
  const BOOST_DOUBLE_MS = 3000;
  let boost = null;
  let lastBoostSpawnAt = -1e15;
  let doubleUntil = 0;

  /***********************
   * éŠæˆ²ç‹€æ…‹
   ***********************/
  let running = false;
  let dir = {x:1,y:0};
  let nextDir = {x:1,y:0};

  let snake = [];
  const INIT_LEN = 1;

  let targets = [];
  let warns = [];

  let desiredCount = 1;
  let nextDesiredRecalcAt = 0;

  let pendingGrowth = 0;
  let score = SCORE_FLOOR;
  let best = Number(localStorage.getItem(BEST_KEY) || 0);
  $best.textContent = fmt(best);

  let streak = 0;
  let lastPositiveEatAt = 0;

  /***********************
   * é€Ÿåº¦ï¼šåˆå§‹ 70%ï¼Œæ™‚é–“è¶Šä¹…è¶Šå¿«ï¼ˆä¿ç•™ï¼‰
   ***********************/
  const SPEED_START = 0.70;
  const baseTickMs = 120 / SPEED_START;
  const baseMinMs  = 92  / SPEED_START;
  const MOM_SPEED_FACTOR = 1.7;
  const MOM_SPEED_MS = baseTickMs / MOM_SPEED_FACTOR;
  const MOM_BOOST_MS = 3000;
  let momBoostUntil = 0;

  let tickMs = baseTickMs;
  let tickHandle = null;
  let gameStartAt = 0;

  /***********************
   * å€’æ•¸ 3,2,1
   ***********************/
  let countdownActive = false;
  let countdownN = 0;
  let countdownTimer = null;
  let countdownEndsAt = 0;

  const elapsedMs = ()=> running ? (Date.now() - gameStartAt) : 0;

  function chebyshevDist(ax, ay, bx, by){
    return Math.max(Math.abs(ax - bx), Math.abs(ay - by));
  }
  function tooCloseToHeadForAngry(x, y){
    const h = snake[0];
    if (!h) return false;
    return chebyshevDist(x, y, h.x, h.y) <= ANGRY_SAFE_RADIUS;
  }

  function multiplierLevel(){ return Math.floor(streak / 10); }
  function scoreMultiplier(){ return 1 + multiplierLevel() * 0.25; }
  function speedFactorFromStreak(){
    const micro = 1 + Math.min(0.20, streak * 0.01);
    const lv = multiplierLevel();
    const tier = (lv >= 1) ? (1 + (0.10 * lv + 0.10)) : 1;
    return micro * tier;
  }

  function effectiveTickMs(){
    const e = elapsedMs();
    const timeBoost = Math.min(1, e / 90000);
    const timeBaseMs = baseTickMs - (baseTickMs - baseMinMs) * timeBoost;

    const sf = speedFactorFromStreak();
    let ms = timeBaseMs / sf;

    if (Date.now() < momBoostUntil) ms = Math.min(ms, MOM_SPEED_MS);
    return clamp(ms, 70, 220);
  }

  function applyTickRate(){
    const newMs = effectiveTickMs();
    if (Math.abs(newMs - tickMs) < 0.5) return;
    tickMs = newMs;
    if (running){
      clearInterval(tickHandle);
      tickHandle = setInterval(tick, tickMs);
    }
  }

  function currentScoreFinalForUI(){
    const bonus = Math.max(0, snake.length - INIT_LEN);
    return Math.max(SCORE_FLOOR, score + bonus);
  }

  function updateDesiredCount(){
    const e = elapsedMs();
    if (Date.now() < nextDesiredRecalcAt) return;
    nextDesiredRecalcAt = Date.now() + 3000;

    let min=1, max=1;
    if (e < 20000) { min=1; max=1; }
    else if (e < 40000) { min=1; max=2; }
    else if (e < 60000) { min=2; max=3; }
    else { min=3; max=4; }

    desiredCount = min + Math.floor(Math.random() * (max - min + 1));
  }

  function ttlForNow(){
    const e = elapsedMs();
    if (e < 20000) return randRange(11000, 15000);
    if (e < 40000) return randRange(10000, 14000);
    if (e < 60000) return randRange(9000, 13000);
    return randRange(7000, 10000);
  }

  function updateUI(){
    $score.textContent = fmt(Math.max(SCORE_FLOOR, score));
    $streak.textContent = String(Math.floor(streak));
    $mult.textContent = "x" + fmt(scoreMultiplier());
    $len.textContent = String(snake.length);

    const boosting = Date.now() < momBoostUntil;
    const sf = speedFactorFromStreak();
    const baseFast = (sf > 1.02);
    if (boosting) $spd.textContent = "èŠ±åª½åŠ é€Ÿä¸­";
    else if (baseFast) $spd.textContent = "é€£åƒåŠ é€Ÿä¸­";
    else $spd.textContent = "æ­£å¸¸";

    $liveItems.textContent = `${targets.length}${boost ? "+åœˆ" : ""}/${desiredCount}`;
    $x2Tag.style.display = (Date.now() < doubleUntil) ? "inline-flex" : "none";
  }

  function cellOccupied(x,y){
    if (snake.some(s => s.x===x && s.y===y)) return true;
    if (targets.some(t => t.x===x && t.y===y)) return true;
    if (warns.some(w => w.x===x && w.y===y)) return true;
    if (boost && boost.x===x && boost.y===y) return true;
    return false;
  }

  function randCell(){
    return { x: Math.floor(Math.random()*GRID), y: Math.floor(Math.random()*GRID) };
  }

  function maxMinesNow(){
    const e = elapsedMs();
    return (e < 60000) ? 1 : 2;
  }
  function canSpawnMom(now){ return (now - lastMomSpawnAt) >= MOM_MIN_GAP_MS; }
  function canSpawnAngry(now){ return (now - lastAngrySpawnAt) >= ANGRY_MIN_GAP_MS; }

  function tryPlaceAtSafeCell(predicate){
    for (let attempt=0; attempt<140; attempt++){
      let c = randCell();
      let tries = 0;
      while (cellOccupied(c.x,c.y) && tries < 600){
        c = randCell(); tries++;
      }
      if (cellOccupied(c.x,c.y)) continue;
      if (predicate && !predicate(c.x,c.y)) continue;
      return c;
    }
    return null;
  }

  function scheduleMomWarn(now){
    const c = tryPlaceAtSafeCell(() => true);
    if (!c) return false;
    warns.push({ x:c.x, y:c.y, spawnAt: now });
    lastMomSpawnAt = now;
    return true;
  }

  function spawnOneTarget(now){
    const e = elapsedMs();
    const minesOnField = targets.filter(t => t.def.key === "ANGRY").length;
    const forbidSoloMine = (desiredCount <= 1);
    const allowChainMine = (e >= 60000) && (Math.random() < 0.18);
    const maxMines = maxMinesNow();

    for (let attempt=0; attempt<180; attempt++){
      let def = pickItemByProb();

      const hasPositiveNow = targets.some(t => t.def.isPositive);
      if (!hasPositiveNow) def = pickPositiveDef();

      if (forbidSoloMine && def.key === "ANGRY") def = pickPositiveDef();

      if (def.key === "MOM"){
        if (!canSpawnMom(now)) continue;
        if (scheduleMomWarn(now)) return true;
        continue;
      }

      if (def.key === "ANGRY"){
        if (!canSpawnAngry(now)) continue;
        if (minesOnField >= maxMines) continue;

        const c = tryPlaceAtSafeCell((x,y)=> !tooCloseToHeadForAngry(x,y));
        if (!c) continue;

        targets.push({ x:c.x, y:c.y, def, bornAt: now, ttlMs: ttlForNow() });
        lastAngrySpawnAt = now;

        if (allowChainMine && targets.filter(t => t.def.key === "ANGRY").length < maxMines){
          const c2 = tryPlaceAtSafeCell((x,y)=> !tooCloseToHeadForAngry(x,y));
          if (c2){
            targets.push({ x:c2.x, y:c2.y, def, bornAt: now, ttlMs: ttlForNow() });
            lastAngrySpawnAt = now;
          }
        }
        return true;
      }

      const c = tryPlaceAtSafeCell(() => true);
      if (!c) continue;

      targets.push({ x:c.x, y:c.y, def, bornAt: now, ttlMs: ttlForNow() });
      return true;
    }

    const safeDef = ITEM_DEFS.find(d => d.key === "ASHUI") || ITEM_DEFS[0];
    const c = tryPlaceAtSafeCell(() => true);
    if (!c) return false;
    targets.push({ x:c.x, y:c.y, def:safeDef, bornAt: now, ttlMs: ttlForNow() });
    return true;
  }

  function maybeSpawnBoost(now){
    const e = elapsedMs();
    if (e < BOOST_AFTER_MS) return;
    if (boost) return;
    if ((now - lastBoostSpawnAt) < BOOST_COOLDOWN_MS) return;

    const p = clamp(0.05 + Math.min(0.05, (e-BOOST_AFTER_MS)/120000*0.05), 0.05, 0.10);
    if (Math.random() > p) return;

    const c = tryPlaceAtSafeCell(() => true);
    if (!c) return;
    boost = { x:c.x, y:c.y, bornAt: now, ttlMs: BOOST_TTL_MS };
    lastBoostSpawnAt = now;
  }

  function rerollTarget(t, now){
    const idx = targets.indexOf(t);
    if (idx >= 0) targets.splice(idx, 1);
    const ok = spawnOneTarget(now);
    if (!ok) targets.push(t);
  }

  function enforceAtLeastOnePositive(now){
    const hasPos = targets.some(t => t.def.isPositive);
    if (hasPos) return;

    const mine = targets.find(t => t.def.key === "ANGRY") || targets[0];
    if (mine){
      const idx = targets.indexOf(mine);
      if (idx >= 0) targets.splice(idx, 1);
    }

    const d = (canSpawnMom(now) && Math.random() < 0.25) ? ITEM_DEFS.find(x=>x.key==="MOM") : pickPositiveDef();
    if (d && d.key === "MOM") scheduleMomWarn(now);
    else {
      const c = tryPlaceAtSafeCell(() => true);
      if (c) targets.push({ x:c.x, y:c.y, def:d, bornAt: now, ttlMs: ttlForNow() });
    }
  }

  function maintainAll(){
    const now = Date.now();
    updateDesiredCount();

    // èŠ±åª½é å‘Š -> 1 ç§’å¾Œå‡ºç¾
    if (warns.length){
      const keep = [];
      for (const w of warns){
        if (now - w.spawnAt >= MOM_WARN_MS){
          const def = ITEM_DEFS.find(d => d.key === "MOM");
          if (def && !cellOccupied(w.x,w.y)){
            targets.push({ x:w.x, y:w.y, def, bornAt: now, ttlMs: ttlForNow() });
            sfxBeep(880, 0.05, "square", 0.10);
          }
        } else {
          keep.push(w);
        }
      }
      warns = keep;
    }

    // x2åœˆï¼šéæœŸæ”¹æˆæ›ä½ç½®
    if (boost){
      if ((now - boost.bornAt) > boost.ttlMs){
        const c = tryPlaceAtSafeCell(() => true);
        if (c){ boost.x = c.x; boost.y = c.y; }
        boost.bornAt = now;
        boost.ttlMs = BOOST_TTL_MS;
      }
    } else {
      maybeSpawnBoost(now);
    }

    // ç‰©ä»¶éæœŸï¼šæ›ä½ç½®/æ›è§’è‰²
    for (const t of [...targets]){
      if ((now - t.bornAt) > t.ttlMs){
        rerollTarget(t, now);
      }
    }

    // è£œåˆ° desiredCount
    let guard = 0;
    while (targets.length < desiredCount && guard++ < 14){
      spawnOneTarget(now);
    }
    while (targets.length > desiredCount){
      targets.pop();
    }

    enforceAtLeastOnePositive(now);
  }

  function applyDoubleMultiplier(val){
    return (Date.now() < doubleUntil) ? (val * 2) : val;
  }

  function onEat(def){
    if (def.isPositive){
      streak += 1;
      lastPositiveEatAt = Date.now();

      const mult = scoreMultiplier();
      const baseAdd = (def.score || 0) * mult;
      score += applyDoubleMultiplier(baseAdd);

      pendingGrowth += (def.grow || 0);

      const pitch = 520 + Math.min(30, Math.floor(streak)) * 18;
      sfxBeep(pitch, 0.06, "sine", 0.18);
      sfxBeep(pitch * 1.18, 0.04, "triangle", 0.12);

      if (def.isEgg){
        momBoostUntil = Date.now() + MOM_BOOST_MS;
        sfxBeep(988, 0.07, "square", 0.20);
        sfxBeep(1319, 0.09, "square", 0.18);
        sfxBeep(1760, 0.11, "triangle", 0.14);
      }
    } else {
      streak = 0;
      lastPositiveEatAt = 0;
      momBoostUntil = 0;

      score += (def.score || 0);

      const shrink = def.shrink || 0;
      pendingGrowth = 0;
      for (let i=0; i<shrink; i++){
        if (snake.length > INIT_LEN) snake.pop();
      }

      sfxBeep(160, 0.09, "sawtooth", 0.22);
      sfxBeep(120, 0.11, "sawtooth", 0.20);
    }

    score = Math.max(SCORE_FLOOR, score);

    applyTickRate();
    updateUI();
  }

  function onEatBoost(){
    doubleUntil = Date.now() + BOOST_DOUBLE_MS;
    sfxBeep(740, 0.06, "triangle", 0.14);
    sfxBeep(988, 0.08, "triangle", 0.14);
    sfxBeep(1319, 0.10, "triangle", 0.12);

    boost = null;

    streak += 1;
    lastPositiveEatAt = Date.now();

    applyTickRate();
    updateUI();
  }

  /***********************
   * éŠæˆ²è¿´åœˆ
   ***********************/
  function tick(){
    if (!running) return;

    // é€£åƒè¡°æ¸›
    if (streak > 0 && lastPositiveEatAt > 0 && (Date.now() - lastPositiveEatAt >= 3000)) {
      streak = Math.max(0, streak - 0.35);
    }

    maintainAll();

    dir = nextDir;
    const head = snake[0];
    const newHead = { x: head.x + dir.x, y: head.y + dir.y };

    if (newHead.x < 0 || newHead.y < 0 || newHead.x >= GRID || newHead.y >= GRID){
      gameOver("æ’åˆ°ç‰†");
      return;
    }
    if (snake.some((s,i)=> i!==0 && s.x===newHead.x && s.y===newHead.y)){
      gameOver("æ’åˆ°è‡ªå·±");
      return;
    }

    snake.unshift(newHead);

    if (boost && newHead.x === boost.x && newHead.y === boost.y){
      onEatBoost();
    }

    const hitIndex = targets.findIndex(t => t.x === newHead.x && t.y === newHead.y);
    if (hitIndex >= 0){
      const t = targets[hitIndex];
      onEat(t.def);
      targets.splice(hitIndex, 1);
      maintainAll();
    }

    // æˆé•·ï¼šæ”¯æ´å°æ•¸ï¼ˆä¾‹å¦‚ +1.5ï¼‰
    if (pendingGrowth >= 1) {
      pendingGrowth -= 1;
    } else if (pendingGrowth > 0) {
      if (Math.random() < pendingGrowth) {
        pendingGrowth = 0;
      } else {
        pendingGrowth = 0;
        snake.pop();
      }
    } else {
      snake.pop();
    }

    applyTickRate();
    updateUI();
    draw();
  }

  function scoreDeltaText(finalScore){
    const prevRaw = localStorage.getItem(LAST_SCORE_KEY);
    const prev = (prevRaw == null) ? null : Number(prevRaw);
    localStorage.setItem(LAST_SCORE_KEY, String(finalScore));

    if (prev == null || Number.isNaN(prev)) return { prevText: "å‰æ¬¡æˆç¸¾ï¼šç„¡", deltaText: "æœ¬æ¬¡æˆç¸¾ï¼šé¦–å±€è¨˜éŒ„" };

    const d = finalScore - prev;
    if (Math.abs(d) < 1e-9) return { prevText: `å‰æ¬¡æˆç¸¾ï¼š${fmt(prev)}`, deltaText: "æœ¬æ¬¡æ¯”å‰æ¬¡ï¼šæŒå¹³" };
    const sign = d > 0 ? "ä¸Šå‡" : "ä¸‹é™";
    const arrow = d > 0 ? "â¬†ï¸" : "â¬‡ï¸";
    return { prevText: `å‰æ¬¡æˆç¸¾ï¼š${fmt(prev)}`, deltaText: `æœ¬æ¬¡æ¯”å‰æ¬¡ï¼š${arrow} ${sign} ${fmt(Math.abs(d))}` };
  }

  function gameOver(reason="æ’åˆ°ç‰†æˆ–è‡ªå·±"){
    running = false;
    clearInterval(tickHandle); tickHandle = null;

    sfxBeep(220, 0.10, "sawtooth", 0.22);
    sfxBeep(196, 0.12, "sawtooth", 0.18);

    const bonus = Math.max(0, snake.length - INIT_LEN);
    const finalScore = Math.max(SCORE_FLOOR, score + bonus);

    if (finalScore > best){
      best = finalScore;
      localStorage.setItem(BEST_KEY, String(best));
      $best.textContent = fmt(best);
    }

    const avaUrl = pickRandomAva();
    const top6 = addScoreToBoard({ name: playerName, score: finalScore, at: Date.now(), avaUrl });

    const { prevText, deltaText } = scoreDeltaText(finalScore);

    openModal({
      title: "éŠæˆ²çµæŸï¼",
      sub: `åŸå› ï¼š${reason}ã€€ï½œã€€çµæŸåŠ æˆï¼šèº«é«”å¤š ${bonus} æ ¼ +${bonus} åˆ†`,
      text:
`ä½ çš„æœ€çµ‚åˆ†æ•¸ï¼š<b>${fmt(finalScore)}</b><br/>
ï¼ˆå³æ™‚åˆ†æ•¸ï¼š${fmt(score)} ï¼‹ é•·åº¦åŠ æˆï¼š${fmt(bonus)}ï¼‰<br/>
${prevText}<br/>
<b>${deltaText}</b>`,
      score: finalScore,
      showRank: true,
      showAgain: true,
      rankData: top6,
      avaUrl
    });
  }

  btnAgain.addEventListener("click", () => {
    closeModal();
    resetGame();
    startCountdownThenGame();
  });
  btnGo.addEventListener("click", () => {
    closeModal();
    resetGame();
    startCountdownThenGame();
  });

  /***********************
   * ç¹ªåœ–ï¼šå¹¾ä½•å·¥å…·
   ***********************/
  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  /***********************
   * âœ… èº«é«”å¤–è§€ï¼šé»ƒåº• + å…©éš»è…³ï¼ˆç´…æ£•å°åœ“é»ï¼‰
   * - æ›´è²¼è¿‘ä½ æä¾›åœ–æ¡†çš„ã€Œä¸‹ç·£ï¼‹å…©è…³ã€æ„Ÿè¦º
   ***********************/
  function drawBody(seg, idx){
    const x = seg.x * CELL, y = seg.y * CELL;

    // èº«é«”ï¼ˆé»ƒï¼‰
    ctx.save();
    ctx.shadowColor = "rgba(0,0,0,.16)";
    ctx.shadowBlur = 10;

    ctx.fillStyle = "#ffd400";  // æ˜é¡¯é»ƒ
    roundRect(x+3, y+3, CELL-6, CELL-6, 12);
    ctx.fill();

    // å¤–æ¡†ï¼ˆæ·±è‰²ï¼‰
    ctx.shadowBlur = 0;
    ctx.lineWidth = 3.2;
    ctx.strokeStyle = "#3b1b14";
    roundRect(x+3, y+3, CELL-6, CELL-6, 12);
    ctx.stroke();

    // å…©éš»è…³ï¼šç”¨å…©å€‹å°åœ“é»ï¼ˆç´…æ£•ï¼‰
    const footR = CELL * 0.13;
    const fy = y + CELL * 0.90;
    const fx1 = x + CELL * 0.32;
    const fx2 = x + CELL * 0.68;

    ctx.fillStyle = "#7b1d1a";
    ctx.beginPath(); ctx.arc(fx1, fy, footR, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(fx2, fy, footR, 0, Math.PI*2); ctx.fill();

    // è…³å¤–æ¡†ï¼ˆæ·±è‰²ï¼Œè²¼è¿‘åœ–æª”é‚Šç·šï¼‰
    ctx.lineWidth = 2.6;
    ctx.strokeStyle = "#3b1b14";
    ctx.beginPath(); ctx.arc(fx1, fy, footR, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(fx2, fy, footR, 0, Math.PI*2); ctx.stroke();

    ctx.restore();
  }

  function drawHead(seg){
    const img = SPR.HEAD;
    const x = seg.x * CELL, y = seg.y * CELL;

    // é ­éƒ¨åº•ï¼ˆè·Ÿèº«é«”ä¸€è‡´ï¼‰
    ctx.save();
    ctx.fillStyle = "#ffd400";
    roundRect(x+3, y+3, CELL-6, CELL-6, 12);
    ctx.fill();
    ctx.lineWidth = 3.2;
    ctx.strokeStyle = "#3b1b14";
    roundRect(x+3, y+3, CELL-6, CELL-6, 12);
    ctx.stroke();
    ctx.restore();

    if (!img) return;

    let ang = 0;
    if (dir.x === 1) ang = 0;
    if (dir.x === -1) ang = Math.PI;
    if (dir.y === 1) ang = Math.PI/2;
    if (dir.y === -1) ang = -Math.PI/2;

    const cx = x + CELL/2;
    const cy = y + CELL/2;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(ang);

    const size = CELL * HEAD_SCALE;
    ctx.drawImage(img, -size/2, -size/2, size, size);
    ctx.restore();
  }

  function drawGridGlow(){
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1;
    for(let i=1;i<GRID;i++){
      ctx.beginPath(); ctx.moveTo(i*CELL,0); ctx.lineTo(i*CELL,cv.height); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,i*CELL); ctx.lineTo(cv.width,i*CELL); ctx.stroke();
    }
    ctx.restore();
  }

  function drawTarget(t){
    const def = t.def;
    const img = SPR[def.key] || null;
    const x = t.x * CELL, y = t.y * CELL;

    ctx.save();
    if (def.isEgg){
      ctx.shadowColor = "rgba(255,200,0,.55)";
      ctx.shadowBlur = 18;
    } else if (def.isMine){
      ctx.shadowColor = "rgba(255,60,60,.55)";
      ctx.shadowBlur = 18;
    } else {
      ctx.shadowColor = "rgba(255,120,190,.35)";
      ctx.shadowBlur = 12;
    }

    const size = CELL * TARGET_SCALE;
    const ox = x + (CELL - size) / 2;
    const oy = y + (CELL - size) / 2;

    if (img) {
      ctx.drawImage(img, ox, oy, size, size);
    } else {
      ctx.fillStyle = def.isMine ? "#ff4d4f" : (def.isEgg ? "#ffd24d" : "#ff5aa5");
      ctx.beginPath();
      ctx.arc(x+CELL/2, y+CELL/2, CELL*0.42, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawMomWarn(w){
    const x = w.x * CELL, y = w.y * CELL;
    const blink = Math.sin((Date.now() - w.spawnAt) / 80) > 0 ? 1 : 0.35;

    ctx.save();
    ctx.globalAlpha = 0.85 * blink;
    ctx.shadowColor = "rgba(255,215,0,.9)";
    ctx.shadowBlur = 22;
    ctx.strokeStyle = "rgba(255,215,0,.95)";
    ctx.lineWidth = 4;
    roundRect(x+3, y+3, CELL-6, CELL-6, 12);
    ctx.stroke();

    ctx.globalAlpha = 0.9 * blink;
    ctx.fillStyle = "rgba(255,215,0,.18)";
    roundRect(x+3, y+3, CELL-6, CELL-6, 12);
    ctx.fill();
    ctx.restore();
  }

  function drawBoost(b){
    const x = b.x * CELL, y = b.y * CELL;
    const t = Date.now() - b.bornAt;
    const pulse = 0.5 + 0.5*Math.sin(t/180);

    ctx.save();
    ctx.shadowColor = "rgba(90,200,255,.75)";
    ctx.shadowBlur = 22;

    ctx.globalAlpha = 0.95;
    ctx.strokeStyle = "rgba(90,200,255,.95)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(x+CELL/2, y+CELL/2, CELL*0.38 + pulse*2, 0, Math.PI*2);
    ctx.stroke();

    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(90,200,255,.25)";
    ctx.beginPath();
    ctx.arc(x+CELL/2, y+CELL/2, CELL*0.32 + pulse*2, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(255,255,255,.95)";
    ctx.font = `900 ${Math.floor(CELL*0.36)}px system-ui`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("x2", x+CELL/2, y+CELL/2);

    ctx.restore();
  }

  function drawCountdownOverlay(){
    if (!countdownActive) return;

    const now = Date.now();
    const remain = Math.max(0, countdownEndsAt - now);
    const t = 1 - clamp(remain / 1000, 0, 1);
    const scale = 1 + (0.25 * (1 - t));
    const alpha = 0.35 + 0.65 * (1 - t);

    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,.45)";
    ctx.fillRect(0,0,cv.width,cv.height);

    ctx.globalAlpha = alpha;
    ctx.fillStyle = "rgba(255,255,255,.92)";
    ctx.font = `900 ${Math.floor(120*scale)}px system-ui, -apple-system`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(String(countdownN), cv.width/2, cv.height/2 - 10);

    ctx.globalAlpha = 0.9;
    ctx.font = `900 ${Math.floor(18)}px system-ui, -apple-system`;
    ctx.fillStyle = "rgba(255,255,255,.85)";
    ctx.fillText("æº–å‚™é–‹å§‹â€¦", cv.width/2, cv.height/2 + 90);

    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);
    ctx.fillStyle = "#0b0b0f";
    ctx.fillRect(0,0,cv.width,cv.height);

    drawGridGlow();

    warns.forEach(drawMomWarn);
    if (boost) drawBoost(boost);
    targets.forEach(drawTarget);

    for (let i=snake.length-1; i>=1; i--) drawBody(snake[i], i);
    drawHead(snake[0]);

    if (!running && !countdownActive){
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.font = "bold 18px system-ui, -apple-system";
      ctx.textAlign = "center";
      ctx.fillText("æŒ‰ã€Œé–‹å§‹ã€æˆ–æ»‘å‹•/æ–¹å‘éµé–‹å§‹", cv.width/2, cv.height/2 - 10);
      ctx.font = "13px system-ui, -apple-system";
      ctx.fillStyle = "rgba(255,255,255,.7)";
      ctx.fillText("èŠ±åª½å…ˆé–ƒå…‰1ç§’å†å‡ºç¾ï¼›60ç§’å¾Œæœƒå‡º x2 åŠ æˆåœˆ", cv.width/2, cv.height/2 + 14);
      ctx.restore();
    }

    drawCountdownOverlay();
  }

  /***********************
   * è¼¸å…¥
   ***********************/
  function setDir(nx, ny){
    if (snake.length > 1 && nx === -dir.x && ny === -dir.y) return;
    nextDir = {x:nx, y:ny};
  }

  function requestStartFromInput(){
    if (!running && !countdownActive) startCountdownThenGame();
  }

  document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowUp") setDir(0,-1);
    if (e.key === "ArrowDown") setDir(0,1);
    if (e.key === "ArrowLeft") setDir(-1,0);
    if (e.key === "ArrowRight") setDir(1,0);
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) requestStartFromInput();
  });

  function bindPad(id, nx, ny){
    const el = document.getElementById(id);
    el.addEventListener("pointerdown", (ev) => {
      ev.preventDefault();
      setDir(nx, ny);
      requestStartFromInput();
    });
  }
  bindPad("up", 0, -1);
  bindPad("down", 0, 1);
  bindPad("left", -1, 0);
  bindPad("right", 1, 0);

  let sx=0, sy=0, st=0;
  cv.addEventListener("touchstart", (e) => {
    const t = e.touches[0];
    sx = t.clientX; sy = t.clientY; st = Date.now();
  }, {passive:true});

  cv.addEventListener("touchend", (e) => {
    const t = e.changedTouches[0];
    const dxT = t.clientX - sx;
    const dyT = t.clientY - sy;
    const dt = Date.now() - st;
    if (dt > 500) return;
    if (Math.abs(dxT) < 18 && Math.abs(dyT) < 18) return;

    if (Math.abs(dxT) > Math.abs(dyT)) setDir(dxT > 0 ? 1 : -1, 0);
    else setDir(0, dyT > 0 ? 1 : -1);

    requestStartFromInput();
  });

  /***********************
   * é–‹å§‹ / ç©æ³•
   ***********************/
  document.getElementById("btnStart").addEventListener("click", () => {
    if (!snake.length) resetGame();
    if (!running && !countdownActive) startCountdownThenGame();
  });

  document.getElementById("btnHow").addEventListener("click", () => {
    const rule =
`ã€é‡é»ç©æ³•ã€‘
â€¢ åƒåˆ°åŠ åˆ†è§’è‰²ï¼šåˆ†æ•¸å¢åŠ ã€èº«é«”è®Šé•·
â€¢ åƒåˆ°ç”Ÿæ°£é¹¿é¹¿ï¼ˆåœ°é›·ï¼‰ï¼š-3 åˆ†ã€èº«é«”ç¸®çŸ­ -2ã€é€£åƒä¸­æ–·ã€é€Ÿåº¦é‡ç½®
â€¢ åˆ†æ•¸æœ€ä½ç¶­æŒ 1 åˆ†ï¼ˆä¸æœƒæ‰åˆ° 1 ä»¥ä¸‹ï¼‰

ã€é€£åƒï¼ˆstreakï¼‰ã€‘
â€¢ é€£çºŒåƒåˆ°ã€ŒåŠ åˆ†é …ç›®ã€æœƒæŒçºŒå¾®å¹…åŠ é€Ÿï¼ˆä¹Ÿæœƒè®“åŠ åˆ†æ›´é«˜ï¼‰

ã€é™æ™‚åŠ æˆåœˆã€‘
â€¢ éŠç© 60 ç§’å¾Œæœƒå‡ºç¾ã€Œx2 åŠ æˆåœˆã€
â€¢ åƒåˆ°å¾Œ 3 ç§’å…§ï¼šåŠ åˆ†é …ç›®å¾—åˆ† x2

ã€ç¯€å¥ã€‘
â€¢ éŠç©è¶Šä¹…ï¼Œæ•´é«”é€Ÿåº¦æœƒé€æ­¥è®Šå¿«
â€¢ å ´ä¸Šæ°¸é è‡³å°‘æœ‰ 1 å€‹åŠ åˆ†é …ç›®`;

    openModal({
      title: "ç©æ³•ï¼ˆç°¡è¦ï¼‰",
      sub: "å¥½ä¸Šæ‰‹ã€è¶Šç©è¶Šåˆºæ¿€",
      text: rule,
      score: currentScoreFinalForUI(),
      showRank: false,
      showClear: false,
      avaUrl: pickRandomAva()
    });
  });

  function showStartIntro(){
    openModal({
      title: "æº–å‚™é–‹å§‹ï¼",
      sub: "æŒ‰é–‹å§‹å¾Œå€’æ•¸ 3ã€2ã€1",
      text:
`â€¢ åŠ åˆ†è§’è‰²ï¼šåŠ åˆ†ï¼‹è®Šé•·<br/>
â€¢ ç”Ÿæ°£é¹¿é¹¿ï¼ˆåœ°é›·ï¼‰ï¼š-3 åˆ†ã€ç¸®çŸ­ -2ã€é€£åƒä¸­æ–·<br/>
â€¢ åˆ†æ•¸æœ€ä½ 1 åˆ†<br/>
â€¢ 60 ç§’å¾Œï¼šx2 åŠ æˆåœˆï¼ˆ3 ç§’ï¼‰<br/>
â€¢ éŠç©è¶Šä¹…é€Ÿåº¦è¶Šå¿«`,
      score: SCORE_FLOOR,
      showGo: true,
      showRank: false,
      showClear: false,
      avaUrl: pickRandomAva()
    });
  }

  /***********************
   * å€’æ•¸é–‹è·‘
   ***********************/
  function startCountdownThenGame(){
    if (running || countdownActive) return;

    ensureAudio();
    if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();

    countdownActive = true;
    countdownN = 3;
    countdownEndsAt = Date.now() + 1000;
    draw();

    sfxBeep(660, 0.06, "square", 0.16);

    clearInterval(countdownTimer);
    countdownTimer = setInterval(() => {
      countdownN -= 1;
      if (countdownN <= 0){
        clearInterval(countdownTimer);
        countdownTimer = null;
        countdownActive = false;
        startGame();
        return;
      }
      countdownEndsAt = Date.now() + 1000;
      sfxBeep(660, 0.06, "square", 0.16);
      draw();
    }, 1000);

    const anim = () => {
      if (!countdownActive) return;
      draw();
      requestAnimationFrame(anim);
    };
    requestAnimationFrame(anim);
  }

  /***********************
   * Reset / Start
   ***********************/
  function resetGame(){
    running = false;
    clearInterval(tickHandle); tickHandle = null;

    countdownActive = false;
    clearInterval(countdownTimer); countdownTimer = null;

    dir = {x:1,y:0};
    nextDir = {x:1,y:0};

    snake = [{ x: Math.floor(GRID/2), y: Math.floor(GRID/2) }];
    pendingGrowth = 0;

    score = SCORE_FLOOR;
    streak = 0;
    lastPositiveEatAt = 0;

    momBoostUntil = 0;
    lastMomSpawnAt = -1e15;
    lastAngrySpawnAt = -1e15;

    boost = null;
    lastBoostSpawnAt = -1e15;
    doubleUntil = 0;

    targets = [];
    warns = [];

    desiredCount = 1;
    nextDesiredRecalcAt = 0;
    gameStartAt = 0;

    updateDesiredCount();
    maintainAll();

    applyTickRate();
    updateUI();
    draw();
  }

  function startGame(){
    if (running) return;
    running = true;
    gameStartAt = Date.now();
    nextDesiredRecalcAt = 0;

    ensureAudio();
    if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
    if ($bgmOn.checked) startBGM();

    maintainAll();
    applyTickRate();
    clearInterval(tickHandle);
    tickHandle = setInterval(tick, tickMs);
  }

  /***********************
   * åˆå§‹åŒ–
   ***********************/
  preload().finally(() => {
    resetGame();
    draw();
    showStartIntro();
  });

})();
</script>
</body>
</html>
